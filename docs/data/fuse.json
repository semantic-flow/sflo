{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"Semantic Flow Documentation","n":0.577},"1":{"v":"\n**Dereferenceable, versioned semantic meshes** will be the foundation for a new era of knowledge graphs.\n\n[[now]] | [[todo]] | [[principle]] | [[dev.contributor.djradon.dev-log]]\n\n## What Is Semantic Flow?\n\n**Semantic Flow** is a framework for managing and publishing resource identifiers, knowledge graphs and other semantic data by leveraging GitHub, Gitlab, and other free static hosting services. It enables a **dereferenceable Semantic Web** where every HTTP IRI returns meaningful content.\n\n[[concept.mesh-repo]] provide storage, [[concept.mesh]] provide resource management and publishing, and [[concept.semantic-site]] support data discovery and explainability.\n\n## Benefits\n\n- own your own self-describing data and data schemas\n- complete version history when you want it\n- reliable persistence\n- truly FAIR (Findable, Accessible, Interoperable, and Reusable)\n\n## Features\n\n- seamlessly integrate other data sources anywhere in your mesh\n- generate and customize mini-sites or single-page applications for nodes in your mesh\n- see [[feature]] for a list of planned features\n","n":0.086}}},{"i":2,"$":{"0":{"v":"Use Case","n":0.707}}},{"i":3,"$":{"0":{"v":"Use Case: Radio Show Websiste","n":0.447},"1":{"v":"\nSuppose DJ Radon wants to publish a website about himself, his musical activities, and maybe some album reviews. Call it a wiki, call it a knowledgebase, call it a show site. \n\nTo get started, he wants to publish his top-5 most-played tracks of the week. \n\nPublishing them as plain-text might be adequate for this situation, but say he eventually wanted to make his site linked: you can click from a playlist, to an album, to a track, to an artist. \n\nBut to get started:\n\n* A **namespace** `/test-ns/`\n* A **thing** `/ns/djradon/`\n* A **dataset** `/ns/djradon/picks/`\n\n#### Mesh Directory Structure\n\n```file\ntest-ns                    # bare node\n   djradon                 # ref node (refering to a human dj)\n      bio                  # data node\n      picks                # data node \n      underbrush           # ref node\n         playlists         # data (series) node\n            1996-11-10     # data node\n            1996-11-17     # data node\n```\n\n#### Sample RDF (Turtle)\n\n1. **Namespace metadata**\n\n   ```turtle\n   # /ns/_id/ns_id.trig\n   <> a sf:Namespace ;\n      dct:title \"Namespace Root\" ;\n      sf:contains <https://example.org/ns/djradon/> .\n   ```\n\n2. **Thing metadata**\n\n   ```turtle\n   # /ns/djradon/_id/djradon_id.trig\n   <> a sf:Thing ;\n      rdfs:label \"djradon\" ;\n      sf:backlink <https://example.org/ns/> .\n   ```\n\n3. **Dataset metadata**\n\n   ```turtle\n   # /ns/djradon/picks/_id/picks_id.trig\n   <> a sf:VersionedDataset ;\n      dct:title \"djradon picks\" ;\n      sf:backlink <https://example.org/ns/djradon/> .\n   ```\n\n4. **Current distribution**\n\n   ```turtle\n   # /ns/djradon/picks/picks.trig\n   <> dct:issued \"2025-06-22\"^^xsd:date ;\n      dct:creator <https://example.org/agents/bot> .\n   ```\n\n5. **Historical version**\n\n   ```turtle\n   # /ns/djradon/picks/_v-series/v1/picks_v1.trig\n   <> dct:issued \"2025-06-01\"^^xsd:date .\n   ```\n\n---\n\nWith these few rules and a tiny folder-walking parser your **Semantic Mesh** is unambiguously self-describing, easy to validate, and ready for any RDF-aware tooling.\n","n":0.066}}},{"i":4,"$":{"0":{"v":"Product","n":1}}},{"i":5,"$":{"0":{"v":"sflo-web","n":1}}},{"i":6,"$":{"0":{"v":"sflo-host","n":1},"1":{"v":"\n- supports the official clients ([[product.cli]] and [[product.sflo-web]]) and third-party clients by\n  - providing an [[product.sflo-api]]\n  - serving meshes via a contained static http service\n  - keeping central control of mesh operations.\n    - e.g. locking sub-meshes during weave.\n    - enables parallelism, which can speed up the weave and ensure processes don't clobber each others' work. It can also provide locking to allow multi-user or multi-client modification.\n\n## Functions\n\n- file watchers\n- file locking\n\n","n":0.119}}},{"i":7,"$":{"0":{"v":"sflo-api","n":1},"1":{"v":"\nTODO: \n\n\n## Mesh Management\n\n### `POST /api/meshes`\n\n**Description**: Registers a new mesh with the service, making it available for further operations. This endpoint does not create any files or nodes; it simply associates a logical name with a filesystem path.\n\n**Request Body**:\n```json\n{\n  \"name\": \"test-ns\",\n  \"path\": \"./test-ns\"\n}\n```\n\n**Success Response (201 Created)**:\n```json\n{\n  \"message\": \"Mesh 'test-ns' registered successfully.\",\n  \"links\": [\n    { \"rel\": \"self\", \"href\": \"/api/meshes/test-ns\" },\n    { \"rel\": \"nodes\", \"href\": \"/api/meshes/test-ns/nodes\" }\n  ]\n}\n```\n\n**HATEOAS Prompting**: If there's no mesh signature (e.g., a `_handle` or `_meta-flow` folder) in the specified path, the response includes a prompt to create a root node:\n\n```json\n{\n  \"message\": \"Mesh 'test-ns' registered successfully. No mesh signature detected.\",\n  \"links\": [\n    { \"rel\": \"self\", \"href\": \"/api/meshes/test-ns\" },\n    { \"rel\": \"nodes\", \"href\": \"/api/meshes/test-ns/nodes\" },\n    { \"rel\": \"create-root-node\", \"href\": \"/api/meshes/test-ns/nodes\", \"method\": \"POST\", \"title\": \"Initialize this mesh by creating a root node\" }\n  ]\n}\n```\n\n### `GET /api/meshes`\n\n**Description**: Lists all registered meshes.\n\n**Success Response (200 OK)**:\n```json\n{\n  \"meshes\": [\n    {\n      \"name\": \"test-ns\",\n      \"path\": \"./test-ns\",\n      \"links\": [\n        { \"rel\": \"self\", \"href\": \"/api/meshes/test-ns\" },\n        { \"rel\": \"nodes\", \"href\": \"/api/meshes/test-ns/nodes\" }\n      ]\n    }\n  ]\n}\n```\n\n## Node Management\n\n### `POST /api/meshes/{meshName}/nodes`\n\n**Description**: Creates a new node at a specified path within a registered mesh. This is used for creating all nodes, including the root node of a mesh.\n\n**URL Parameters**:\n- `{meshName}`: The logical name of the mesh (e.g., \"test-ns\").\n\n**Request Body**:\n```json\n{\n  \"path\": \"/\",\n  \"nodeType\": \"Namespace\",\n  \"initialData\": {\n    \"title\": \"djradon's primary semantic mesh\"\n  },\n  \"options\": {\n    \"copyDefaultAssets\": true\n  }\n}\n```\n\n**Key Body Parameters**:\n- `path`: The relative path for the new node. For the root node, use `/` or an empty string; the API will return `/{meshName}/` as its path.\n- `nodeType`: The type of node to create (\"Namespace\", \"Reference\", or \"Dataset\").\n- `initialData`: An object containing the initial metadata for the node.\n- `options.copyDefaultAssets`: A boolean to indicate if default assets (templates, CSS) should be copied into the mesh. This is typically `true` only when creating the root node.\n\n**Success Response (201 Created)**:\n```json\n{\n  \"message\": \"Node created successfully at path '/test-ns/' in mesh 'test-ns'.\",\n  \"nodePath\": \"/test-ns/\",\n  \"filesCreated\": [\n    \"./test-ns/index.html\",\n    \"./test-ns/_meta-component/v1.trig\"\n  ],\n  \"links\": [\n    { \"rel\": \"self\", \"href\": \"/api/meshes/test-ns/nodes/test-ns/\" },\n    { \"rel\": \"mesh\", \"href\": \"/api/meshes/test-ns\" }\n  ]\n}\n```\n\n### Other Node Endpoints\n\n- `GET /api/meshes/{meshName}/nodes/{path}` - Retrieve node\n- `PUT /api/meshes/{meshName}/nodes/{path}` - Update node\n- `DELETE /api/meshes/{meshName}/nodes/{path}` - Delete node\n- `POST /api/meshes/{meshName}/nodes/{path}/graft` - Start a new node from an existing snapshot\n\n## Weave and Distribution\n\n- `POST /api/meshes/{meshName}/weave` - Trigger weave operation\n- `POST /api/meshes/{meshName}/dataset/upload` - Upload RDF dataset distribution\n- `GET /api/meshes/{meshName}/dataset/{path}/versions` - List dataset versions\n- `POST /api/meshes/{meshName}/assets/upload` - Upload binary file resources\n\n## Service Management\n\n\n## \n\n### mesh registration\n\n\n### node initialization\n\n\n#### differences with mesh init\n\n- same as mesh initialization, except:\n  - specify an [[sflo.concept.relative-identifier]] and select a parent node (or specify a path which is equivalent),\n  - by default, no template/css copy\n\n### weave\n\n- copy any [[sflo.concept.mesh.resource.folder._next]]  to  \n","n":0.048}}},{"i":8,"$":{"0":{"v":"CLI","n":1},"1":{"v":"\n## Stand-alone or Service-backed\n\n- the CLI can function alone, but when used in tandem with the [[sflo.product.service]], it becomes multi-user and multi-threaded\n\n## Commands\n\n- list\n","n":0.204}}},{"i":9,"$":{"0":{"v":"Guide","n":1}}},{"i":10,"$":{"0":{"v":"Best Practices","n":0.707}}},{"i":11,"$":{"0":{"v":"Todo","n":1},"1":{"v":"\n- rename ontologies:\n  - flow-service-ontology.jsonld -> sflo-host-ontology.jsonld\n  - config-flow-ontology.jsonld -> node-config-ontology.jsonl\n  - update concept.mesh.resource.element.node-config-defaults \n","n":0.258}}},{"i":12,"$":{"0":{"v":"mesh resource","n":0.707},"1":{"v":"\n## Overview\n\nA **mesh resource** is any addressable component within a [[semantic mesh|concept.mesh]]. Every mesh resource has a unique [[Intramesh|concept.identifier.intramesh]] based on its path and locally unique name, making it dereferenceable via URL.\n\nIn RDF terms, a resource is any node in an RDF graph that can be represented with an IRI (the other kinds of RDF graph nodes are literals and blank nodes). So theoretically, files and folders in [[resource.node-component.asset-tree]] could be considered RDF resources. But they are not considered **mesh** resources\n\n## Types of Mesh Resources\n\nThe structure of a semantic mesh is built on a fundamental distinction between **extensible** and **terminal** resources:\n\n- **[[Mesh nodes|resource.node]]** are extensible namespace containers:\n- **[[Mesh node components|resource.node-component]]** are terminal mesh resources:\n  - Can be physically represented as folders or files\n    - Folder [[concept.identifier.intramesh]] are part of the namespace but cannot be extended beyond their own internal structure\n  - All files and folders within a component folder are considered to be part of the parent node\n\n**Folder-based components:**\n\n\n- **[[metadata flows|resource.node-component.flow.node-metadata]]**: Administrative metadata (in `_meta-flow/` folders)\n- **[[Asset trees|resource.node-component.asset-tree]]**: File collections (in `_assets/` folders)\n- **[[Version datasets|resource.node-component.flow-snapshot.version]]**: Versioned snapshots\n- **[[next snapshots|resource.node-component.flow-snapshot.next]]**: Draft workspaces\n\n**File-based components:**\n- **Documentation files**: \n  - [[Resource pages|resource.node-component.documentation-resource.resource-page]] are index.html files that provide de-referencability for their containing [[concept.identifier.intramesh]] [[facet.filesystem.folder]]\n  - **README.md and CHANGELOG.md**: unstructured documentation\n- **[[snapshot distribution files|resource.node-component.snapshot-distribution]]**: Data files in RDF formats\n\n## Physical vs Logical Structure\n\n**Physical Representation:**\n- Mesh nodes and components are represented as folders in the filesystem\n- File resources are represented as individual files\n- Folder names become namespace segments and URL path components\n\n**Logical Function:**\n- All mesh resources are addressable via their URL path\n- URLs must return meaningful content when dereferenced\n- Resources maintain semantic relationships through containment and cross-references\n\n## Asset Tree Special Case\n\n[[Asset trees|resource.node-component.asset-tree]] represent a special category where:\n- The asset tree itself (with its [[resource.node-component.flow.node-metadata]]) is part of the mesh structure\n- The files and folders contained within asset trees are \"attached to\" but not \"contained in\" the mesh\n- Asset tree contents are addressable but are not considered semantic flow resources\n\nThis distinction maintains clean separation between semantic mesh structure and arbitrary file attachments while preserving addressability.\n","n":0.054}}},{"i":13,"$":{"0":{"v":"mesh node","n":0.707},"1":{"v":"\n## Overview\n\nThe primary constituents of a semantic mesh are **mesh nodes**. They are physically represented as [[mesh folders|facet.filesystem.folder]] and establish a [[namespace segments|concept.namespace.segment]].\n\nMesh nodes are holonic containers that can contain other mesh nodes [[node components|resource.node-component]], distinguishing them from components which are terminal within their own scope.\n\n## Physical Structure\n\nWhen stored on disk, all mesh nodes:\n- Are physically represented as folders in the filesystem\n- Extend the identifier namespace with their folder name\n- Can be further extended by containing other mesh resources\n\n## Mandatory Components\n\nEvery mesh node has these components:\n\n- **[[resource.node-component.flow.node-metadata]]** ([[folder._node-metadata-flow]]): Centralized metadata for the node\n- **[[resource.node-component.node-handle]]** (`_node-handle/`): Universal marker folder that refers to the parent \"as a mesh node\", as opposed to \"as the name, dataset, or other thing\" to which it normally refers; a handle resource page should explain this distinction\n\n## Optional Components\n\n- \n\n## Node Types\n\n### 1. [[bare node|resource.node.bare]]\n**Components**: `_meta-flow/` + `_node-handle/`\n- Functions as organizational containers\n- Contains essential identity, metadata, and handle information\n- Node IRI refers to the namespace itself\n- Base level for all mesh nodes\n\n\n### 2. [[data node|resource.node.reference.dataset]]\n**Components**: `_meta-flow/` + `_node-handle/` + `_data-flow/`\n- Contains data distributions and versioning capabilities\n- Node URL refers to the node’s referent (real-world entity or dataset concept) represented by the data flow\n- Adds dataset storage to the namespace foundation\n- Can be configured as [[dataset series|faq.do-data-nodes-support-datasetseries]]\n- Evolved from bare nodes by adding the `_data-flow/` component\n- Maintains single referent principle\n","n":0.067}}},{"i":14,"$":{"0":{"v":"reference node","n":0.707},"1":{"v":"\n## Definition\n\nA **reference node** is a [[resource.node]] that represents the (non-dataset) **referent** of the node — i.e., the thing in the world that the node stands for.\n\n**Purpose**\n\n* To describe what the node *refers to* (person, place, concept, dataset, etc.).\n* To supply human/machine labels, identifiers, and minimal provenance about the referent.\n* To differentiate between metadata about the **node itself** (`_node-metadata-flow`) and metadata about the **referent**.\n\n**Contents (typical minimum)**\n\n* `rdfs:label` (human-readable name of the referent).\n* `rdf:type` (classifying what kind of thing the referent is).\n* Optional provenance (creator, source, temporal scope).\n* Optional identifiers (sameAs links, external URIs).\n\n## Example Snapshot Distribution\n\n```trig\n# The referent of the node (the actual person)\n<djradon>\n    rdf:type foaf:Person ;\n    rdfs:label \"dj radon\" ;\n    foaf:mbox <mailto:djradon@example.org> ;\n```\n","n":0.094}}},{"i":15,"$":{"0":{"v":"dataset reference nodes","n":0.577},"1":{"v":"\n## Overview\n\n**Dataset reference nodes** (or “data nodes” for short) are [[resource.node.reference]]s that represent and contain an evolvable \"payload\" dataset in the form of a [[resource.node-component.flow.data]]. \n\nBecause it is evolvable, it gets typed as a [DatasetSeries](https://www.w3.org/TR/vocab-dcat-3/#Class:Dataset_Series)it [[concept.identifier.intramesh]]\n\nIts actual data is kept in a [[resource.node-component.flow]]\n\nIts versions are [[datasets|https://www.w3.org/TR/vocab-dcat-3/#Class:Dataset]].\n\nUnlike [[flow snapshots|resource.node-component.flow-snapshot]] which contain concrete data distributions, data nodes serve as conceptual containers that organize and provide identity for data without containing the data directly. I.e., data nodes only contain concrete datasets by virtue of containing [[resource.node-component.flow.data]] (also abstract) and its snapshots, which have concrete distributions.\n\ndata nodes are physically represented as [[mesh folders|facet.filesystem.folder]] and correspond to [[namespace segments|concept.namespace.segment]].\n\n## Abstract vs Concrete Data\n\n### Abstract Data Concept (data node)\nA data node represents the **idea** or **concept** represented by a dataset:\n- `/ns/djradon/bio/` = a biographical dataset about the person djradon\n- `/ns/census/` =  the results of a census\n- `/ns/weather-stations/` = \"the concept of weather station data\"\nThis idea or concept is the referent of the data node's URL. \n\nThe data node provides:\n- **Stable identity**: The concept persists even as concrete data changes\n- **Organizational structure**\n\n### Data flow (DatasetSeries)\n\n[[resource.node-component.flow.data]] is the single user data flow for a node, realized by snapshots:\n\n- `/ns/monsters/_data-flow/_current/` = the current dataset snapshot\n- `/ns/weather-stations/_data-flow/_v3/` = version 3 dataset snapshot\n\nSnapshots contain **distribution files**: the actual data in various formats (e.g., .trig, .jsonld)\n\n## Required Structure\n\nEvery data node must contain:\n\n- **[[resource.node-component.flow.node-metadata]]** (`_meta-flow/`): Administrative metadata about the data concept\n- **[[resource.node-component.flow.data]]** (`_data-flow/`): dataset data\n- **[[Node handle|resource.node-component.node-handle]]** (`_node-handle/`): Referential indirection for the node\n\n## Optional Structure\n\n- **[[Asset trees|resource.node-component.asset-tree]]** (`_assets/`): Attached file collections\n- [[resource.node-component.documentation-resource.changelog]] and [[resource.node-component.documentation-resource.readme]]\n- [[resource.node-component.node-config-defaults]]\n\n## Key Characteristics\n\n### Not a Dataset\n\n**Important**: A data node does not refer to a specifc RDF graph; it is **not itself a (concrete) dataset**. It represents the abstract concept of a dataset that may evolve over time:\n- data nodes are never versioned (only their components are)\n- data nodes serve as stable conceptual anchors\n\n\n\n### Extensible Container\nLike all mesh nodes, data nodes can contain other mesh nodes and components, making them extensible namespace containers.\n\n## Examples\n\n### Unversioned data node\n```\nns/monsters/\n├── _meta-flow/                 # metadata about the \"monsters\" data node\n├── _node-handle/               # handle for the data node\n└── _data-flow/                 # single data flow\n    └── _current/               # current dataset snapshot\n        ├── monsters.jsonld     # concrete distribution of the current snapshot\n        └── monsters.trig\n```\n","n":0.052}}},{"i":16,"$":{"0":{"v":"bare node","n":0.707},"1":{"v":"\n## Definition\n\n**Bare nodes** are [[resource.node]]s that function primarily as containers for other mesh nodes. They are physically represented by [[folder.namespace]].\n\n## Purpose\n\n- scaffolding, grouping, deferred semantics\n- a secondary, optional function is as \"semantic contextualizers\", but bare nodes don't have any definitive [[concept.referent]] of their own. \n","n":0.149}}},{"i":17,"$":{"0":{"v":"node component","n":0.707},"1":{"v":"\n## Overview\n\n**Node components** are mesh resources that support and define the mesh structure. Unlike [[mesh nodes|resource.node]] which can contain other mesh nodes, components cannot be extended beyond their own internal structure.\n\nComponents can be physically represented as folders or files, and all files and folders within a component folder are considered to be part of that component.\n\n## Component Categories\n\nComponents are categorized by their facets, including:\n  - typical creation and maintenance patterns (user vs system)\n  - versioning status\n  - folder vs. file\n  - node role (meta and data [[resource.node-component.flow]])\n\n### User Components\n\nUser components are primarily created and maintained by users or their software agents and services, and represent domain knowledge:\n\n**Folder-based user components:**\n- **[[Asset trees|resource.node-component.asset-tree]]**: Collections of arbitrary files attached to the mesh (in `_assets/` folders)\n- **[[Next datasets|resource.node-component.flow-snapshot.next]]**: Draft workspaces for ongoing changes to [[resource.node-component.flow]] (in `_next/` folders)\n\n**File-based user components:**\n- **README.md files**: User documentation providing context\n- **CHANGELOG.md files**: Version history documentation\n\n### System Components\n\nSystem components are usually created or altered by the [[Weave Process|concept.weave-process]] process rather than direct user modification:\n\n**Folder-based system components:**\n- **[[metadata flows|resource.node-component.flow.node-metadata]]**: Administrative and structural metadata for mesh nodes (in `_meta-flow/` folders)\n- **[[version snapshot|resource.node-component.flow-snapshot.version]]**: Versioned snapshots of datasets (in `_vN/` folders)\n- **[[Node handles|resource.node-component.node-handle]]**: Components providing referential indirection for nodes as mesh resources (in `_node-handle/` folders)\n\n**File-based system components:**\n- **[[Resource pages|resource.node-component.documentation-resource.resource-page]]**: Generated index.html files for human-readable access\n- **[[Distribution files|resource.node-component.snapshot-distribution]]**: Data files in various RDF formats\n\n## Physical vs Logical Structure\n\n**Physical Representation:**\n- Folder-based components are represented as folders with underscore prefixes (like `_meta-flow/`, `_assets/`)\n- File-based components are individual files within mesh nodes or other components\n- Component folders contain all files and folders that belong to that component\n\n**Logical Function:**\n- Components extend the namespace but are terminal (cannot contain other mesh nodes or components)\n- Components provide specialized functionality: metadata, versioning, referential data, or file attachments\n- Components maintain the semantic structure and operational capabilities of the mesh\n\n## Integration with Nodes\n\nComponents work in conjunction with mesh nodes to create the complete mesh structure:\n- Every mesh node contains at least two components: metadata flows and node handles\n- data nodes contain a single [[resource.node-component.flow.data]] \n- Any node may contain asset trees (user components) for file attachments\n","n":0.054}}},{"i":18,"$":{"0":{"v":"Handle","n":1}}},{"i":19,"$":{"0":{"v":"handle resource page","n":0.577},"1":{"v":"\n- provides an accessible description of its containing [[resource.node-component.node-handle]]. \n- be default it could be something simple like \"For Semantic Web purposes, this URL should be considered to connote the Semantic Mesh Node <ns/djradon>, not djradon the thing.\"","n":0.162}}},{"i":20,"$":{"0":{"v":"snapshot distribution","n":0.707},"1":{"v":"\n- each [[resource.node-component.flow-snapshot]] should have one or more distributions.\n- a snapshot's distributions should all contain the same data, just in different syntaxes \n\n## Distribution Filenaming Per Flow\n\n-  [[resource.node-component.flow.reference]], [[resource.node-component.flow.node-metadata]], [[resource.node-component.flow.node-config.operational]] and [[resource.node-component.flow.node-config.inheritable]] have their distributions named with `_ref`, `_meta`, `_config` and `_inheritable-config` respectively\n- [[resource.node-component.flow.data]] distributions use the node slug as the base filename (no \"_data\" suffix):\n\n### Filenaming Per Snapshot\n\n- In `_current/`: `slug.ext` (e.g., `dave-bio.trig`, `dave-bio.jsonld`)\n- In `_vN/`: `slug_vN.ext` (e.g., `dave-bio_v1.trig`)\n  In `_next/`: `slug_next.ext` (e.g., `dave-bio_next.trig`)\n","n":0.115}}},{"i":21,"$":{"0":{"v":"node handle","n":0.707}}},{"i":22,"$":{"0":{"v":"Node Config Defaults","n":0.577},"1":{"v":"\n## Overview\n\nNode config defaults are inheritable settings that provide baseline behavior for nodes. They are supplied by ancestors (and service/platform) and are resolved by a mechanism similar to that of service config config.\n\n- Inheritance mechanism: see [[resource.node-component.flow.node-config.inheritable]]\n- Operational (final) config: see [[resource.node-component.flow.node-config.operational]]\n- Folder overview for config flows: see [[resource.node-component.flow.node-config]]\n\n## Common default settings (examples)\n\n- Flow versioning: on/off (whether abstract flows create `_vN/` snapshots on weave)\n- Distribution syntaxes: preferred serializations (e.g., TriG, JSON‑LD)\n- Resource pages and fragments: enable page/fragment generation; template and stylesheet selection\n- Aggregated distributions: on/off for generating top-level rollups\n- Rights & provenance defaults: copyright/licensing/attribution/delegation policies (applied at snapshot time)\n\nThese defaults apply when a node does not specify the setting in its [[resource.node-component.flow.node-config.operational]]; “most specific wins” from parent → service → platform (see [[resource.node-component.flow.node-config.inheritable]] for precedence).\n\n## Minimal guidance\n\n- Keep defaults lightweight; override at the node only when needed\n- Prefer repository‑level templates/css in `_assets/` for consistency (see [[resource.node-component.asset-tree]])\n- Review defaults when moving/embedding meshes to ensure expected publication behavior\n","n":0.08}}},{"i":23,"$":{"0":{"v":"node flow","n":0.707},"1":{"v":"\n[[Nodes|resource.node]] are primarily constituted by their node flows, which are evolvable datasets about their node's metadata, configuration, referent, or payload datasets. They exist through time, independent of any specific version or realization, and can evolve semi-independently from other flows\n\nThere are five types of node flows.\n\n- [[resource.node-component.flow.node-metadata]] (required)\n- [[resource.node-component.flow.node-config.operational]] (optional)\n- [[resource.node-component.flow.node-config.inheritable]] (optional)\n- [[resource.node-component.flow.reference]] (optional)\n- [[resource.node-component.flow.data]] (for data nodes)\n\n\n## Relationship to snapshots\n\nAs DatasetSeries, node flows are realized through [[resource.node-component.flow-snapshot]] datasets, which are temporal slices of the flow. To borrow a phrase from the PROV model, we say that a snapshot is a specialization of the node flow.\n\n### Relationship pattern:\n\nEvery node flow has at least two concrete snapshots: [[resource.node-component.flow-snapshot.current]] and [[resource.node-component.flow-snapshot.next]].\n\nThe node flow is a [DatasetSeries](https://www.w3.org/TR/vocab-dcat-3/#Class:Dataset_Series) and may have multiple [[resource.node-component.flow-snapshot.version]]s.\n\n\n### Ontology Example\n\n- node flow: \"My ontology definitions\" (persistent concept)\n- flow snapshots: v1, v2, current version, working draft of next version (specific realizations)\n\n\n```file\n/my-ontology/\n└── _data-flow/                  ← node flow (ontology definitions)\n    ├── _current/           ← flow snapshot (in this case, probably )\n    ├── _next/           ← flow snapshot\n    ├── _v1/           ← flow snapshot\n    └── _v2/                ← flow snapshot\n```\n\nIn this example:\n\nEach _current/, _v1/, etc. contains flow snapshot realizations\n\n## Persistent Identity\n\nnode flows provide conceptual continuity by:\n\n- Maintaining meaning across versions and changes\n- Preserving references from external sources\n- Enabling evolution while keeping identity stable\n- Supporting versioning without losing conceptual coherence\n","n":0.069}}},{"i":24,"$":{"0":{"v":"reference flow","n":0.707},"1":{"v":"\n## Definition\n\nA **reference flow** is a dataset series within a mesh node that provides information about the **referent** of the node — i.e., the thing in the world that the node stands for.\n\n**Purpose**\n\n* To describe what the node *refers to*, i.e., its referent (person, place, concept, event, dataset, etc.).\n* To supply labels and alternative identifiers for the referent.\n* To refer to other descriptive data about the referent.\n\n## Typical Contents\n\n* `rdfs:label` (human-readable name of the referent).\n* `rdf:type` (classifying what kind of thing the referent is).\n* Optional identifiers (sameAs links, external URIs).\n\n## Example Snapshot Distribution\n\n```trig\n# The referent of the node (the actual person)\n<djradon>\n    rdf:type foaf:Person ;\n    rdfs:label \"dj radon\" ;\n    foaf:mbox <mailto:djradon@example.org> ;\n```\n","n":0.095}}},{"i":25,"$":{"0":{"v":"metadata flow","n":0.707},"1":{"v":"\nA **metadata flow** contains system-related administrative and structural metadata for every [[resource.node]], including the versioning data for each node's flows.\n\nIn the filesystem, it exists as a [[folder._node-metadata-flow]] in a [[folder.node]].\n\nMesh-specific metadata about a node's flows' [[resource.node-component.flow-snapshot.version]]s mostly lives here too, eliminating the need to keep separate metadata in the node component. Also may contain metadata about the assets folder.\n\n## Use of _node-handle in metadata flows\n\nWhen metadata flows (or any [[facet.system]] dataset) refer to mesh nodes, they'll usually be talking about \"the-node-as-mesh-constituent\", so they'll use the node's [[resource.node-component.node-handle]] identifier\n\n## Recommended vocabulary\n","n":0.105}}},{"i":26,"$":{"0":{"v":"meshnode config flows","n":0.577},"1":{"v":"\nNode configuration is managed through two distinct flows that provide settings for a node's behavior.\n\n1.  **[[Operational Config Flow|resource.node-component.flow.node-config.operational]]**: This flow contains the final, resolved configuration that dictates how a specific node operates.\n\n2.  **[[Inheritable Config Flow|resource.node-component.flow.node-config.inheritable]]**: This flow contains settings that a node makes available to its descendants in the mesh hierarchy.\n\nWhile there are two separate flows, there is a single inheritance mechanism that resolves the final operational configuration for a node. This mechanism draws from the `inheritable` configs of parent nodes, as well as service and platform-level defaults.\n","n":0.107}}},{"i":27,"$":{"0":{"v":"operational config flow","n":0.577},"1":{"v":"\nAn **operational config flow** defines a node's final, resolved settings. It is the direct consumer of the configuration inheritance chain and controls the node's actual behavior (e.g., versioning, distribution formats).\n\nIf a node has an operational config flow, it can still inherit settings from the [[inheritance chain|resource.node-component.flow.node-config.inheritable]]. Any settings explicitly defined in the operational config will override those that would have been inherited.\n\nIf a node lacks an operational config flow, its behavior is determined by the resolved settings from the inheritance chain, with service defaults and platform defaults filling in any gaps.\n","n":0.105}}},{"i":28,"$":{"0":{"v":"inheritable config flow","n":0.577},"1":{"v":"\nAn **inheritable config flow** contains settings that a node makes available to its descendants in the mesh hierarchy. It is the primary mechanism for providing default configurations to child nodes.\n\n## Inheritance Hierarchy\n\nThe inheritance chain follows this precedence (most specific wins):\n\n1.  **Parent Node's** InheritableNodeConfig\n2.  **Grandparent Node's** InheritableNodeConfig (and so on, up the tree)\n3.  **Service-level** InheritableNodeConfig\n4.  **Platform-level** InheritableNodeConfig (ultimate fallback)\n\nThe final `OperationalNodeConfig` for a given node is resolved by merging the settings from this chain.\n\n## Resolution Algorithm\n\nWhen resolving a node's operational configuration, the system walks up the hierarchy from the node's parent, collecting `InheritableNodeConfig` at each level. These are merged, with settings from closer ancestors taking precedence.\n\n### Property-Level Inheritance\n\nConfiguration inheritance works at the property level. A child's `InheritableNodeConfig` can override a single property while still inheriting others from its parent.\n\n```jsonld\n{\n  \"@id\": \"parent:inheritableConfig\",\n  \"@type\": \"node-conf:InheritableNodeConfig\",\n  \"node-conf:versioningEnabled\": true,\n  \"node-conf:distributionFormats\": [\"application/trig\", \"application/ld+json\"]\n}\n\n{\n  \"@id\": \"child:inheritableConfig\",\n  \"@type\": \"node-conf:InheritableNodeConfig\",\n  \"node-conf:versioningEnabled\": false\n  // Inherits distributionFormats from parent\n}\n```\n\n## Configuration Control Properties\n\n### `nodeConfigInheritanceEnabled` (Child's Perspective)\n\nControls whether a node *receives* inherited configuration.\n-   **Default**: `true`\n-   **Effect**: When `false`, the node ignores the inheritance chain and uses only its own operational config or system defaults.\n\n### `inheritableConfigPropagationEnabled` (Parent's Perspective)\n\nControls whether a node *provides* its inheritable configuration to its children.\n-   **Default**: `true`\n-   **Effect**: When `false`, this node acts as a \"firewall,\" blocking its own and any ancestor's inheritable configs from flowing down to its children.\n","n":0.068}}},{"i":29,"$":{"0":{"v":"data flow","n":0.707},"1":{"v":"\nData flows provide versionable data storage functionality within the semantic mesh architecture. \n\n## Overview\n\nA data flow (sometimes called a __payload__ flow) is a series of RDF graphs that carry the actual statements about a node’s referent. Whether the node represents a dataset, a person, a character, or any other entity, its data flow is where those facts live. Each data flow has snapshots (_current/, _next/, _vN/) that track its evolution over time. \n\nData flows are distinct from metadata flows, which are managed by the platform and describe the mesh resource itself; and configuration flows, which govern behavior.\n\n\n## Purpose\n\ndata flows serve as the primary content containers for mesh nodes, providing:\n\n- **Content Storage**: Hold the actual data payload that defines the node's content\n- **History**: Support multiple versions (snapshots) of the same conceptual dataset\n- **Format Diversity**: Provide multiple format distributions (TTL, JSON-LD, etc.)\n- **State Management**: Track current, draft, and versioned states of data\n\n## Structure\n\nData flows organize content through [[flow snapshots|resource.node-component.flow-snapshot]]:\n\n- `_current/` - Current stable version of the dataset\n- `_next/` - Draft/work-in-progress version\n- `_v1/`, `_v2/`, etc. - Versioned snapshots for historical access\n\nLike all [[facet.filesystem.folder]], they should contain an `index.html` [[resource.node-component.documentation-resource.resource-page]] -- a human-readable description for the flow.\n\n## Distribution Formats\n\nEach [[flow snapshot|resource.node-component.flow-snapshot]] typically provides multiple format distributions:\n\n- **Trig (.trig)**: Primary RDF serialization\n- **JSON-LD (.jsonld)**: JSON-compatible linked data\n- **RDF/XML (.xml or .trix)**: XML-based RDF serialization\n- **N-Quads (.nq)**: Line-based RDF format\n\n## Example\n\nFrom the [[semantic mesh example|concept.semantic-mesh.example]]:\n\n```\n/test-ns/djradon-bio/_data-flow          # data flow\n├── _current/                        # current snapshot\n│   ├── djradon-bio.ttl             # turtle distribution\n│   ├── djradon-bio.jsonld          # json-ld distribution\n│   └── index.html                  # snapshot interface\n├── _next/                          # draft snapshot\n│   ├── djradon-bio.ttl             # draft turtle\n│   ├── djradon-bio.jsonld          # draft json-ld\n│   └── index.html                  # snapshot interface\n└── index.html                      # resource page\n```\n\n## Integration\n\ndata flows integrate with other mesh components:\n\n- **metadata flows**: Provide provenance and management data\n- **Asset Trees**: Store associated files and media\n- **Resource Pages**: Provide human-readable interfaces\n","n":0.058}}},{"i":30,"$":{"0":{"v":"flow snapshot","n":0.707},"1":{"v":"\n**flow snapshots** are components that are datasets and represent the evolutionary steps of the [[resource.node-component.flow]].  \n\nflow snapshots have corresponding [[distributions|resource.node-component.snapshot-distribution]] and are the connective tissue between nodes and their RDF-based representation.\n\n## Relationship to node flows\n\nflow snapshots are the successive realizations of [[resource.node-component.flow]].\n\n### Relationship pattern:\n\nnode flows have at least two snapshots:\n\n- current version (`_current/`)\n- working draft (`_next`)\n- versioned snapshots\n\n### Ontology data node Example\n\n```file\n/my-ontology/               ← data node: Conceptual, data-oriented \"thing\"\n├── _meta-flow/                   ← meta flow (metadata)\n│   ├── _current/           ← flow snapshot (current metadata)\n│   ├── _next/              ← flow snapshot (working draft)\n│   ├── _v1/                ← flow snapshot (version 1 metadata)\n│   └── _v2/                ← flow snapshot (version 2 metadata)\n└── _data-flow/                  ← data node flow (ontology definition--by-dataset)\n    ├── _current/           ← flow snapshot (current definition)\n    ├── _next/              ← flow snapshot (working draft)\n    └── _v1/                ← flow snapshot (version 1 definition)\n```\n\nIn this example:\n- `_current/`, `_v1/`, `_v2/`, `_next/` are all flow snapshots\n- Each contains actual data files and distributions\n- They represent specific temporal states of their parent node flows\n\n## Temporal Nature\n\nflow snapshots capture datasets at specific moments:\n\n- **Current versions** (`_current/`) - The latest version.\n- **Next versions** (`_next/`) - Draft content for future release\n- **Historical versions** (`_v1/`, `_v2/`) - Immutable snapshots from the past\n\n## Content Structure\n\nflow snapshots contain:\n- **Data files** - The actual dataset content (`.ttl`, `.rdf`, `.jsonld`)\n- **Distributions** - Multiple format representations of the same data\n- **Metadata** - Information about the specific version/snapshot\n\n### Example Structure\n```file\n_current/\n├── my-ontology.ttl         ← Distribution\n├── my-ontology.rdf         ← Distribution  \n└── my-ontology.jsonld      ← Distribution\n```\n\n## Immutability\n\n**[[resource.node-component.flow-snapshot.version]]** (historical flow snapshots, i.e., versioned folders like `_v1/`, `_v2/`) should be treated as immutable once created. This provides reliable references for external systems and ensures accurate provenance and history.\n\n**[[resource.node-component.flow-snapshot.current]]** (the latest \"woven\" flow snapshots, `_current`) should not be modified directly by users, but will be updated \"on weave\" if the [[resource.node-component.flow-snapshot.next]] has evolved. \n\n**[[resource.node-component.flow-snapshot.next]]** (working flow snapshots, `_next/`) are mutable:\n- Can be edited and updated during development\n- Represent evolving state of the node flow\n\n## Creation and Lifecycle\n\nflow snapshots are created through:\n- **Initial authoring** - Creating `_current/` content\n- **Versioning** - Snapshotting `_current/` to `_v1/`, `_v2/` during [[concept.weave]]\n- **Draft preparation** - Working in `_next/` for future releases\n\n## Related Concepts\n\n- **[[resource.node-component.flow]]** - Parent conceptual entities\n- **[[concept.versioning]]** - Process of creating versioned flow snapshots\n- **[[concept.weave-process]]** - Operation that manages flow snapshot lifecycle\n","n":0.052}}},{"i":31,"$":{"0":{"v":"version snapshot","n":0.707},"1":{"v":"\nA snapshot or checkpoint dataset generated \"on [[weave|concept.weave-process]]\"\n\n## Disambiguation\n\n- a version snapshot is an addressable resource; it is differentiated from the concept of a [[facet.flow.versioned]] in that a versioned flow is a flow that has ever had a version.\n","n":0.16}}},{"i":32,"$":{"0":{"v":"next snapshot","n":0.707},"1":{"v":"\nThe **next snapshot** serves as a draft workspace for ongoing changes to a node's [[resource.node-component.flow]]s\nAfter a version-bumping weave, a next snapshot starts identically to the current dataset but can be modified safely without affecting the stable current version. During weaving, _next content becomes the new current dataset and gets snapshotted as the latest version, while _next naturally remains ready for the next round of drafts.\n\nThis allows continuous development and version control commits without requiring immediate version bumps or disrupting users of the stable dataset.\n","n":0.109}}},{"i":33,"$":{"0":{"v":"current snapshot","n":0.707},"1":{"v":"\nThe current snapshot represents the latest published version of a dataset's content. It serves as the authoritative source that users and external systems reference, containing the most recent released data while remaining unchanged during active development.\n\nIf versioning is turned on and nobody has cleaned up old versions, the current snapshot matches the content of the latest versioned snapshot (e.g., `_v3/`) and remains identical to the [[resource.node-component.flow-snapshot.next]] until new changes begin. During weaving, the `_next` content becomes the new current snapshot. If versioning is turned on, the _next content becomes the next version.\n\nThis provides a reference point for citations and external links that want the latest information, while allowing ongoing development work to proceed safely in the `_next` dataset without disrupting users of the published data.\n","n":0.089}}},{"i":34,"$":{"0":{"v":"Documentation Resource","n":0.707}}},{"i":35,"$":{"0":{"v":"mesh resource page","n":0.577},"1":{"v":"\nTo make every folder-based resource more discoverable, they each have an index.html page that gets generate \"on [[concept.weave-process]]\"\n\n\n- primarily for humans\n\n## References\n\n- https://www.w3.org/wiki/DereferenceURI\n","n":0.209}}},{"i":36,"$":{"0":{"v":"Resource Fragment","n":0.707},"1":{"v":"\nResource fragments are [[product.service.design.htmx]] fragments, support dynamic behaviour in [[resource.node-component.documentation-resource.resource-page]] or external web apps without a \"live\" backend.\n\nFor resource pages, they're most useful for \"saving bandwidth\": data that might not be needed can be loaded later.\n\nFor external apps, they save the overhead of parsing and discovery.\n\nFragment generation can be configured per node or inherited from config hierarchy.\n\n## **Multiple Resource Fragments in Assets**\n\nThis is a natural extension of your asset tree concept (.9):\n\n```\nmesh-node/\n├── _assets/\n│   ├── fragments/               # Generated resource pages\n│   │   ├── README.html          # generated from README.md\n│   │   ├── CHANGELOG.html       # generated from CHANGELOG.md\n│   │   └── back-references.html # list of back-references\n│   └── styles/\n│       └── common.css\n├── _meta-flow/\n├── CHANGELOG.md\n└── README.md\n```\n\n","n":0.097}}},{"i":37,"$":{"0":{"v":"README","n":1},"1":{"v":"\n- Provides an unstructured introduction to the containing resource\n- preferably written in Markdown. \n","n":0.267}}},{"i":38,"$":{"0":{"v":"CHANGELOG","n":1},"1":{"v":"\n- provides an unstructure history of the containing resources\n- preferably written in Markdown. \n","n":0.267}}},{"i":39,"$":{"0":{"v":"assets tree","n":0.707},"1":{"v":"\nThis node component is \"mesh-terminal\" and should contain no [[sflow-resources|resource]]. \n\nIt can be contained in any [[folder.node]], i.e., only Nodes get assets trees.\n\nIts metadata (if any) should be stored in the parent node’s meta flow (`_meta-flow/`). Asset trees are terminal and carry no flows, and are ignored by the mesh scanner.\n\nIt can contain an arbitrary set of files and folders, but two (optional) folders are special:\n- _templates can contain html files to be used when generating [[resource.node-component.documentation-resource.resource-page]] for the containing [[resource.node]] or its sub-resources.\n","n":0.109}}},{"i":40,"$":{"0":{"v":"Aggregated Distribution","n":0.707},"1":{"v":"\n__note: maybe we will do them, maybe we won't__\n\nA node's **aggregated distribution** is a compilation of all the child data flows of its contained data nodes (their `_data-flow/_current/` snapshots), situated directly under the parent node with an intuitive filename like \"nodename.ext\".\n\nBoth [[resource.node.bare]] and [[resource.node.reference.dataset]] can have aggregate distributions. data nodes include their own data in the aggregation.\n\n## Purpose\n\nAggregated distributions enable **composable semantic data** by:\n- Combining contained nodes data into a single resource\n- Supporting modular ontology and knowledge base construction\n\n## Generation Process\n\nDuring [[concept.weave-process]], aggregated distributions are created by:\n1. **Scanning contained data nodes** recursively within the mesh structure\n2. **Collecting `_data-flow/_current/` distributions** from each flow\n3. **Merging content** with proper URI resolution and prefix handling\n4. **Excluding `_config` and `_meta` datasets** (data content only)\n5. **Generating multiple distributions** (.ttl, .rdf, .jsonld) as configured\n\n## Examples\n\n### Composable Ontology\n```\n/my-ontology/\n├── my-ontology.ttl              ← Aggregated distribution\n├── my-ontology.rdf              ← Aggregated distribution  \n├── my-ontology.jsonld           ← Aggregated distribution\n├── components/\n│   ├── Person/                  ← data node (class definition)\n│   ├── hasName/                 ← data node (property definition)\n│   └── Organization/            ← data node (class definition)\n```\n\n### Knowledge Base\n```\n/biotech-kb/\n├── biotech-kb.ttl               ← Aggregated distribution\n├── biotech-kb.jsonld            ← Aggregated distribution\n├── companies/\n│   ├── genentech/               ← Company data node\n│   └── moderna/                 ← Company data node\n└── products/\n    ├── drug-x/                  ← Product data node\n    └── vaccine-y/               ← Product data node\n```\n\n## Technical Considerations\n\n**Merging logic handles:**\n- **Relative path resolution** - Converting relative URIs to absolute\n- **Prefix consolidation** - Deduplicating namespace declarations\n- **Graph merging** - Combining RDF graphs from multiple sources; de-duplicating\n- **Base URI handling** - Ensuring consistent URI resolution\n\n## Use Cases\n\n- **Ontologies** - Classes and properties from contained nodes\n- **Vocabularies** - Terms and definitions from specialized nodes  \n- **Catalogs** - Dataset metadata from multiple sources\n- **Knowledge bases** - Facts distributed across domain-specific nodes\n- **Configuration data** - Settings aggregated from component services\n\n## Related Concepts\n\n- **[[resource.node-component.flow.data]]** - Source datasets for aggregation\n- **[[concept.weave-process]]** - Process that generates aggregated distributions\n- **[[resource.node-component.flow-snapshot]]** - Contains the actual distributions being aggregated\n","n":0.057}}},{"i":41,"$":{"0":{"v":"Product Ideas","n":0.707}}},{"i":42,"$":{"0":{"v":"Sparql Sync","n":0.707},"1":{"v":"\n- detects changes in a [[concept.semantic-site]] and updates a triple-store as appropriate\n- on demand, scans a triple-store and updates a site as appropriate.","n":0.209}}},{"i":43,"$":{"0":{"v":"Hateoas Driven API Recipe","n":0.5},"1":{"v":"\n## Your Use Case\n\nYou're not just documenting the API — you're using it:\n\n-   To **operate a mesh manually**, before clients exist.\n    \n-   You need an **executable interface**, not just static documentation.\n    \n-   You want **structured examples** (i.e. **recipes**) that can act as proto-clients or decision-paths.\n    \n-   You lean toward **HATEOAS** style: i.e., user follows links (or rels), maybe inputting small bits along the way.\n    \n\n___\n\n## 🔥 This is _not_ what Scalar is designed for\n\nScalar is a **docs tool**, great for:\n\n-   Rendering OpenAPI reference UIs.\n    \n-   Hosting and styling spec-based endpoints.\n    \n-   **Not** for chaining calls, dynamic flows, or acting like a human-in-the-loop client.\n    \n\nEven Stoplight or RapiDoc start to feel clunky in your context, because what you’re actually describing is closer to:\n\n### \\> ✅ A human-usable API client with structured, composable, inspectable **API macros or flows**\n\n___\n\n## 🚨 So yes, you probably need to build something.\n\nBut here's how to think about it critically, so you **don’t throw away everything** or reinvent everything either.\n\n___\n\n## 🧠 What You Actually Want: A “HATEOAS Recipe Runner”\n\nYou’re describing a system that does the following:\n\n| Feature                        | Description                                                    |\n| ------------------------------ | -------------------------------------------------------------- |\n| 🔧 **Embeds real OpenAPI**      | So you get type safety, endpoint listings, schemas, validation |\n| 🧪 **Can execute requests**     | Full HTTP interaction, possibly with state/cookies/token       |\n| 🪜 **Supports recipes/flows**   | Sequence of calls, possibly branching via hypermedia           |\n| 🧵 **Has local state/input**    | To reuse values from previous steps                            |\n| 📎 **HATEOAS link traversal**   | e.g. follow `\"next\"` or `\"create\"` link relations dynamically  |\n| 🧰 **Deno/TS-native**           | So it integrates with your mesh, Weave, etc.                   |\n| 🧭 **Interactive + replayable** | You can try things, backtrack, debug                           |\n\n## Your Use Case\n\nYou're not just documenting the API — you're using it:\n\n-   To **operate a mesh manually**, before clients exist.\n    \n-   You need an **executable interface**, not just static documentation.\n    \n-   You want **structured examples** (i.e. **recipes**) that can act as proto-clients or decision-paths.\n    \n-   You lean toward **HATEOAS** style: i.e., user follows links (or rels), maybe inputting small bits along the way.\n    \n\n___\n\n## 🔥 This is _not_ what Scalar is designed for\n\nScalar is a **docs tool**, great for:\n\n-   Rendering OpenAPI reference UIs.\n    \n-   Hosting and styling spec-based endpoints.\n    \n-   **Not** for chaining calls, dynamic flows, or acting like a human-in-the-loop client.\n    \n\nEven Stoplight or RapiDoc start to feel clunky in your context, because what you’re actually describing is closer to:\n\n### \\> ✅ A human-usable API client with structured, composable, inspectable **API macros or flows**\n\n___\n\n## 🚨 So yes, you probably need to build something.\n\nBut here's how to think about it critically, so you **don’t throw away everything** or reinvent everything either.\n\n___\n\n## 🧠 What You Actually Want: A “HATEOAS Recipe Runner”\n\nYou’re describing a system that does the following:\n\n| Feature                        | Description                                                    |\n| ------------------------------ | -------------------------------------------------------------- |\n| 🔧 **Embeds real OpenAPI**      | So you get type safety, endpoint listings, schemas, validation |\n| 🧪 **Can execute requests**     | Full HTTP interaction, possibly with state/cookies/token       |\n| 🪜 **Supports recipes/flows**   | Sequence of calls, possibly branching via hypermedia           |\n| 🧵 **Has local state/input**    | To reuse values from previous steps                            |\n| 📎 **HATEOAS link traversal**   | e.g. follow `\"next\"` or `\"create\"` link relations dynamically  |\n| 🧰 **Deno/TS-native**           | So it integrates with your mesh, Weave, etc.                   |\n| 🧭 **Interactive + replayable** | You can try things, backtrack, debug                           |\n\n## Your Use Case\n\nYou're not just documenting the API — you're using it:\n\n-   To **operate a mesh manually**, before clients exist.\n    \n-   You need an **executable interface**, not just static documentation.\n    \n-   You want **structured examples** (i.e. **recipes**) that can act as proto-clients or decision-paths.\n    \n-   You lean toward **HATEOAS** style: i.e., user follows links (or rels), maybe inputting small bits along the way.\n    \n\n___\n\n## 🔥 This is _not_ what Scalar is designed for\n\nScalar is a **docs tool**, great for:\n\n-   Rendering OpenAPI reference UIs.\n    \n-   Hosting and styling spec-based endpoints.\n    \n-   **Not** for chaining calls, dynamic flows, or acting like a human-in-the-loop client.\n    \n\nEven Stoplight or RapiDoc start to feel clunky in your context, because what you’re actually describing is closer to:\n\n### \\> ✅ A human-usable API client with structured, composable, inspectable **API macros or flows**\n\n___\n\n## 🚨 So yes, you probably need to build something.\n\nBut here's how to think about it critically, so you **don’t throw away everything** or reinvent everything either.\n\n___\n\n## 🧠 What You Actually Want: A “HATEOAS Recipe Runner”\n\nYou’re describing a system that does the following:\n\n| Feature                        | Description                                                    |\n| ------------------------------ | -------------------------------------------------------------- |\n| 🔧 **Embeds real OpenAPI**      | So you get type safety, endpoint listings, schemas, validation |\n| 🧪 **Can execute requests**     | Full HTTP interaction, possibly with state/cookies/token       |\n| 🪜 **Supports recipes/flows**   | Sequence of calls, possibly branching via hypermedia           |\n| 🧵 **Has local state/input**    | To reuse values from previous steps                            |\n| 📎 **HATEOAS link traversal**   | e.g. follow `\"next\"` or `\"create\"` link relations dynamically  |\n| 🧰 **Deno/TS-native**           | So it integrates with your mesh, Weave, etc.                   |\n| 🧭 **Interactive + replayable** | You can try things, backtrack, debug                           |\n\n## Your Use Case\n\nYou're not just documenting the API — you're using it:\n\n-   To **operate a mesh manually**, before clients exist.\n    \n-   You need an **executable interface**, not just static documentation.\n    \n-   You want **structured examples** (i.e. **recipes**) that can act as proto-clients or decision-paths.\n    \n-   You lean toward **HATEOAS** style: i.e., user follows links (or rels), maybe inputting small bits along the way.\n    \n\n___\n\n## 🔥 This is _not_ what Scalar is designed for\n\nScalar is a **docs tool**, great for:\n\n-   Rendering OpenAPI reference UIs.\n    \n-   Hosting and styling spec-based endpoints.\n    \n-   **Not** for chaining calls, dynamic flows, or acting like a human-in-the-loop client.\n    \n\nEven Stoplight or RapiDoc start to feel clunky in your context, because what you’re actually describing is closer to:\n\n### \\> ✅ A human-usable API client with structured, composable, inspectable **API macros or flows**\n\n___\n\n## 🚨 So yes, you probably need to build something.\n\nBut here's how to think about it critically, so you **don’t throw away everything** or reinvent everything either.\n\n___\n\n## 🧠 What You Actually Want: A “HATEOAS Recipe Runner”\n\nYou’re describing a system that does the following:\n\n| Feature                        | Description                                                    |\n| ------------------------------ | -------------------------------------------------------------- |\n| 🔧 **Embeds real OpenAPI**      | So you get type safety, endpoint listings, schemas, validation |\n| 🧪 **Can execute requests**     | Full HTTP interaction, possibly with state/cookies/token       |\n| 🪜 **Supports recipes/flows**   | Sequence of calls, possibly branching via hypermedia           |\n| 🧵 **Has local state/input**    | To reuse values from previous steps                            |\n| 📎 **HATEOAS link traversal**   | e.g. follow `\"next\"` or `\"create\"` link relations dynamically  |\n| 🧰 **Deno/TS-native**           | So it integrates with your mesh, Weave, etc.                   |\n| 🧭 **Interactive + replayable** | You can try things, backtrack, debug                           |\n\n## Your Use Case\n\nYou're not just documenting the API — you're using it:\n\n-   To **operate a mesh manually**, before clients exist.\n    \n-   You need an **executable interface**, not just static documentation.\n    \n-   You want **structured examples** (i.e. **recipes**) that can act as proto-clients or decision-paths.\n    \n-   You lean toward **HATEOAS** style: i.e., user follows links (or rels), maybe inputting small bits along the way.\n    \n\n___\n\n## 🔥 This is _not_ what Scalar is designed for\n\nScalar is a **docs tool**, great for:\n\n-   Rendering OpenAPI reference UIs.\n    \n-   Hosting and styling spec-based endpoints.\n    \n-   **Not** for chaining calls, dynamic flows, or acting like a human-in-the-loop client.\n    \n\nEven Stoplight or RapiDoc start to feel clunky in your context, because what you’re actually describing is closer to:\n\n### \\> ✅ A human-usable API client with structured, composable, inspectable **API macros or flows**\n\n___\n\n## 🚨 So yes, you probably need to build something.\n\nBut here's how to think about it critically, so you **don’t throw away everything** or reinvent everything either.\n\n___\n\n## 🧠 What You Actually Want: A “HATEOAS Recipe Runner”\n\nYou’re describing a system that does the following:\n\n| Feature                        | Description                                                    |\n| ------------------------------ | -------------------------------------------------------------- |\n| 🔧 **Embeds real OpenAPI**      | So you get type safety, endpoint listings, schemas, validation |\n| 🧪 **Can execute requests**     | Full HTTP interaction, possibly with state/cookies/token       |\n| 🪜 **Supports recipes/flows**   | Sequence of calls, possibly branching via hypermedia           |\n| 🧵 **Has local state/input**    | To reuse values from previous steps                            |\n| 📎 **HATEOAS link traversal**   | e.g. follow `\"next\"` or `\"create\"` link relations dynamically  |\n| 🧰 **Deno/TS-native**           | So it integrates with your mesh, Weave, etc.                   |\n| 🧭 **Interactive + replayable** | You can try things, backtrack, debug                           |\n\n## Your Use Case\n\nYou're not just documenting the API — you're using it:\n\n-   To **operate a mesh manually**, before clients exist.\n    \n-   You need an **executable interface**, not just static documentation.\n    \n-   You want **structured examples** (i.e. **recipes**) that can act as proto-clients or decision-paths.\n    \n-   You lean toward **HATEOAS** style: i.e., user follows links (or rels), maybe inputting small bits along the way.\n    \n\n___\n\n## 🔥 This is _not_ what Scalar is designed for\n\nScalar is a **docs tool**, great for:\n\n-   Rendering OpenAPI reference UIs.\n    \n-   Hosting and styling spec-based endpoints.\n    \n-   **Not** for chaining calls, dynamic flows, or acting like a human-in-the-loop client.\n    \n\nEven Stoplight or RapiDoc start to feel clunky in your context, because what you’re actually describing is closer to:\n\n### \\> ✅ A human-usable API client with structured, composable, inspectable **API macros or flows**\n\n___\n\n## 🚨 So yes, you probably need to build something.\n\nBut here's how to think about it critically, so you **don’t throw away everything** or reinvent everything either.\n\n___\n\n## 🧠 What You Actually Want: A “HATEOAS Recipe Runner”\n\nYou’re describing a system that does the following:\n\n| Feature                        | Description                                                    |\n| ------------------------------ | -------------------------------------------------------------- |\n| 🔧 **Embeds real OpenAPI**      | So you get type safety, endpoint listings, schemas, validation |\n| 🧪 **Can execute requests**     | Full HTTP interaction, possibly with state/cookies/token       |\n| 🪜 **Supports recipes/flows**   | Sequence of calls, possibly branching via hypermedia           |\n| 🧵 **Has local state/input**    | To reuse values from previous steps                            |\n| 📎 **HATEOAS link traversal**   | e.g. follow `\"next\"` or `\"create\"` link relations dynamically  |\n| 🧰 **Deno/TS-native**           | So it integrates with your mesh, Weave, etc.                   |\n| 🧭 **Interactive + replayable** | You can try things, backtrack, debug                           |\n\n## Your Use Case\n\nYou're not just documenting the API — you're using it:\n\n-   To **operate a mesh manually**, before clients exist.\n    \n-   You need an **executable interface**, not just static documentation.\n    \n-   You want **structured examples** (i.e. **recipes**) that can act as proto-clients or decision-paths.\n    \n-   You lean toward **HATEOAS** style: i.e., user follows links (or rels), maybe inputting small bits along the way.\n    \n\n___\n\n## 🔥 This is _not_ what Scalar is designed for\n\nScalar is a **docs tool**, great for:\n\n-   Rendering OpenAPI reference UIs.\n    \n-   Hosting and styling spec-based endpoints.\n    \n-   **Not** for chaining calls, dynamic flows, or acting like a human-in-the-loop client.\n    \n\nEven Stoplight or RapiDoc start to feel clunky in your context, because what you’re actually describing is closer to:\n\n### \\> ✅ A human-usable API client with structured, composable, inspectable **API macros or flows**\n\n___\n\n## 🚨 So yes, you probably need to build something.\n\nBut here's how to think about it critically, so you **don’t throw away everything** or reinvent everything either.\n\n___\n\n## 🧠 What You Actually Want: A “HATEOAS Recipe Runner”\n\nYou’re describing a system that does the following:\n\n| Feature                        | Description                                                    |\n| ------------------------------ | -------------------------------------------------------------- |\n| 🔧 **Embeds real OpenAPI**      | So you get type safety, endpoint listings, schemas, validation |\n| 🧪 **Can execute requests**     | Full HTTP interaction, possibly with state/cookies/token       |\n| 🪜 **Supports recipes/flows**   | Sequence of calls, possibly branching via hypermedia           |\n| 🧵 **Has local state/input**    | To reuse values from previous steps                            |\n| 📎 **HATEOAS link traversal**   | e.g. follow `\"next\"` or `\"create\"` link relations dynamically  |\n| 🧰 **Deno/TS-native**           | So it integrates with your mesh, Weave, etc.                   |\n| 🧭 **Interactive + replayable** | You can try things, backtrack, debug                           |\n\n## Your Use Case\n\nYou're not just documenting the API — you're using it:\n\n-   To **operate a mesh manually**, before clients exist.\n    \n-   You need an **executable interface**, not just static documentation.\n    \n-   You want **structured examples** (i.e. **recipes**) that can act as proto-clients or decision-paths.\n    \n-   You lean toward **HATEOAS** style: i.e., user follows links (or rels), maybe inputting small bits along the way.\n    \n\n___\n\n## 🔥 This is _not_ what Scalar is designed for\n\nScalar is a **docs tool**, great for:\n\n-   Rendering OpenAPI reference UIs.\n    \n-   Hosting and styling spec-based endpoints.\n    \n-   **Not** for chaining calls, dynamic flows, or acting like a human-in-the-loop client.\n    \n\nEven Stoplight or RapiDoc start to feel clunky in your context, because what you’re actually describing is closer to:\n\n### \\> ✅ A human-usable API client with structured, composable, inspectable **API macros or flows**\n\n___\n\n## 🚨 So yes, you probably need to build something.\n\nBut here's how to think about it critically, so you **don’t throw away everything** or reinvent everything either.\n\n___\n\n## 🧠 What You Actually Want: A “HATEOAS Recipe Runner”\n\nYou’re describing a system that does the following:\n\n| Feature                        | Description                                                    |\n| ------------------------------ | -------------------------------------------------------------- |\n| 🔧 **Embeds real OpenAPI**      | So you get type safety, endpoint listings, schemas, validation |\n| 🧪 **Can execute requests**     | Full HTTP interaction, possibly with state/cookies/token       |\n| 🪜 **Supports recipes/flows**   | Sequence of calls, possibly branching via hypermedia           |\n| 🧵 **Has local state/input**    | To reuse values from previous steps                            |\n| 📎 **HATEOAS link traversal**   | e.g. follow `\"next\"` or `\"create\"` link relations dynamically  |\n| 🧰 **Deno/TS-native**           | So it integrates with your mesh, Weave, etc.                   |\n| 🧭 **Interactive + replayable** | You can try things, backtrack, debug                           |\n\n## Your Use Case\n\nYou're not just documenting the API — you're using it:\n\n-   To **operate a mesh manually**, before clients exist.\n    \n-   You need an **executable interface**, not just static documentation.\n    \n-   You want **structured examples** (i.e. **recipes**) that can act as proto-clients or decision-paths.\n    \n-   You lean toward **HATEOAS** style: i.e., user follows links (or rels), maybe inputting small bits along the way.\n    \n\n___\n\n## 🔥 This is _not_ what Scalar is designed for\n\nScalar is a **docs tool**, great for:\n\n-   Rendering OpenAPI reference UIs.\n    \n-   Hosting and styling spec-based endpoints.\n    \n-   **Not** for chaining calls, dynamic flows, or acting like a human-in-the-loop client.\n    \n\nEven Stoplight or RapiDoc start to feel clunky in your context, because what you’re actually describing is closer to:\n\n### \\> ✅ A human-usable API client with structured, composable, inspectable **API macros or flows**\n\n___\n\n## 🚨 So yes, you probably need to build something.\n\nBut here's how to think about it critically, so you **don’t throw away everything** or reinvent everything either.\n\n___\n\n## 🧠 What You Actually Want: A “HATEOAS Recipe Runner”\n\nYou’re describing a system that does the following:\n\n| Feature                        | Description                                                    |\n| ------------------------------ | -------------------------------------------------------------- |\n| 🔧 **Embeds real OpenAPI**      | So you get type safety, endpoint listings, schemas, validation |\n| 🧪 **Can execute requests**     | Full HTTP interaction, possibly with state/cookies/token       |\n| 🪜 **Supports recipes/flows**   | Sequence of calls, possibly branching via hypermedia           |\n| 🧵 **Has local state/input**    | To reuse values from previous steps                            |\n| 📎 **HATEOAS link traversal**   | e.g. follow `\"next\"` or `\"create\"` link relations dynamically  |\n| 🧰 **Deno/TS-native**           | So it integrates with your mesh, Weave, etc.                   |\n| 🧭 **Interactive + replayable** | You can try things, backtrack, debug                           |","n":0.02}}},{"i":44,"$":{"0":{"v":"Fluree Connector","n":0.707},"1":{"v":"\n## User Story\n\nAs a user of semantic meshes, I would like to be able to query an RDF database\nthat is synced to my [[concept.mesh-repo]]. Fluree is one option -- it has\na cloud version for easy data hosting\n","n":0.164}}},{"i":45,"$":{"0":{"v":"Principles","n":1}}},{"i":46,"$":{"0":{"v":"transposability","n":1},"1":{"v":"\n//TODO: re-verify this ai-generated content\n\n## Overview\n\nTransposability is the ability to:\n\n1. move a [[concept.mesh]] to a different serving locations without breaking its internal structure; i.e., A transposable mesh works correctly regardless of which namespace contains it.\n2. move a [[concept.mesh.sub]] to a different part of the mesh\n\nIf you use \n\n\n## Key Principles\n\n### 1. No Hardcoded BASE URIs\n\nSemantic Flow never hardcodes BASE URIs in RDF distribution files. Instead, it relies on the RDF specification's default behavior where parsers use the document's retrieval URL as the base URI.\n\n**Why this works:**\n- When a mesh is served from `github.io/mesh/`, relative URIs resolve relative to that location\n- When the same mesh is served from `mysite.com/data/`, relative URIs resolve relative to that location\n- The mesh's internal structure remains consistent in both cases\n\n### 2. URI Reference Strategies\n\n- see [[faq.reference-iri-choices]]\n\n### 3. Publication History Tracking\n\n- see [[concept.publication]]\n\n## Transposition Scenarios\n\n### Moving Complete Meshes\n\nA complete mesh can be moved between repos, accounts, or hosting providers:\n\n```bash\n# Original location\nhttps://djradon.github.io/mesh/\n\n# New location after moving repo\nhttps://myorganization.github.io/data-mesh/\n\n# Or new hosting provider\nhttps://mysite.com/semantic-data/\n```\n\nAll internal relationships continue to work because they resolve relative to the new serving location.\n\n### Moving Submeshes Within Hierarchy\n\nWhile technically possible, moving parts of a mesh to different parent namespaces should be **discouraged** as it breaks the permanence principle of semantic identifiers. URIs should remain stable over time.\n\nExample of what to avoid:\n```bash\n# Discouraged: moving bio from one parent to another\nns/djradon/projects/bio/ → ns/djradon/bio/\n```\n\nThis changes the permanent identifier for the bio resource and may break external references.\n\n## Implementation Benefits\n\n### No Build Step Required\n\nMeshes work directly when served from any static file server:\n- GitHub Pages\n- Netlify  \n- Apache/Nginx\n- Local file system\n\n### Standards Compliance\n\nTransposability leverages standard RDF parsing behavior rather than custom mechanisms, ensuring compatibility with existing RDF tools and libraries.\n\n## Best Practices\n\n1. **Use relative URIs** for all intra-mesh references\n2. **Move complete meshes** rather than reorganizing internal structure\n3. **Maintain stable namespaces** to preserve identifier permanence\n4. **Test transposition** by serving from different locations\n5. **Validate RDF** after moving to ensure parser compatibility\n\nTransposability ensures that Semantic Flow meshes remain portable and can be deployed flexibly across different hosting environments while maintaining their semantic integrity.\n","n":0.054}}},{"i":47,"$":{"0":{"v":"Single Referent Principle","n":0.577},"1":{"v":"\n- An IRI should refer to only one thing\n- this is NOT the \"single name\" principle; multiple IRIs can refer to the same thing\n\n## Issues\n\n- meaning evolves over time. An IRI that once meant one thing, will come to be something different. Perhaps with versioning readily available, specifying the version helps uphold this principle.\n","n":0.136}}},{"i":48,"$":{"0":{"v":"pseudo-immutability","n":1},"1":{"v":"\nIn a filesystem-based structure like a [[concept.mesh]], you can't really prevent changes. But some things in a mesh should be treated as immutable, like [[resource.node-component.flow-snapshot.version]] and [[concept.identifier.intramesh]].\n\n**Pseudo-immutability** acknowledges that things might be changed, for various reasons:\n\n- accidental changes\n- \"cleaning up\" of data for legal reasons, e.g.: personally-identifiable information (PII) or \"the right to be forgotten.\"\n- fixing of typos or other errors\n- re-organizing namespaces\n\nIf you're updating a dataset, the principle of pseudo-immutability is preserved in that the old data can still exist and be discoverable from the metadata \n\n\n**Psuedo-immutability** also acknowledges that for non-atomic data especially, \"the next version\" is going to keep changing until a checkout or \"weave\". And that sometime you want the \"latest\" data for a given resource, and without sophisticated database management (e.g., )\n\n\n## Mitigations\n\n- metadata can track changes and supply reasons\n- tooling can be used to make changes in ways that don't break the API\n","n":0.082}}},{"i":49,"$":{"0":{"v":"Dereferencability for Humans","n":0.577},"1":{"v":"\nIf you put any [[resource]]'s URL in a browser, it should return some useful context. \n\n \n\n\n## References\n\n- https://ld4pe.dublincore.org/learning_resource/making-uris-published-on-data-web-rdf-dereferencable/\n","n":0.229}}},{"i":50,"$":{"0":{"v":"composability","n":1},"1":{"v":"\n## Overview\n\nComposability is the ability to combine meshes. Semantic Flow enables flexible mesh composition by allowing any mesh node to contain other nodes: the mesh node \n\n## Key Concepts\n\n### Mesh Boundaries\n\nA mesh is identified as a folder that looks like a [[folder.node]], i.e., has (at least) these two subfolders:\n\n\n### Upward Reference Problem\n\nWhen extracting submeshes, upward references can break. For example, if something within `ns/djradon/bio/` references `../../` (pointing to `ns/djradon/`), that reference will break if only the `bio/` subtree is copied elsewhere.\n\n### Weaving Process Solution\n\nDuring weaving, tools:\n1. **Scan for broken relatives**: Check all relative URLs in the mesh\n2. **Convert broken ones**: Replace with absolute URLs using canonical publication data\n3. **Leave working relatives alone**: Preserve transposability where possible\n\nAfter weaving, submeshes are semantically complete and can be composed using standard file operations.\n\n## Incorporating External Meshes\n\n### Importing (No External Connection)\n\nImport meshes or submeshes as permanent copies with no ongoing connection to the source:\n\n```bash\n# Method 1: Git archive (clean, can target specific paths)\ngit archive --remote=https://github.com/djradon/mesh.git main ns/djradon/ | tar -x -C collaborators/\ngit add collaborators/djradon/\ngit commit -m \"Import djradon's mesh\"\n\n# Method 2: Download and copy\ncurl -L https://github.com/djradon/mesh/archive/main.zip -o mesh.zip\nunzip mesh.zip\ncp -r mesh-main/ns/djradon/ collaborators/djradon/\ngit add collaborators/djradon/\ngit commit -m \"Import djradon's mesh\"\n```\n\nThe imported content becomes permanently part of your repository with no external dependencies.\n\n### Embedding (Maintains External Connection)\n\nEmbed external meshes while maintaining a connection for updates:\n\n```bash\n# Import with ongoing connection to source repo\ngit subtree add --prefix=collaborators/djradon/ https://github.com/djradon/mesh.git main --squash\n\n# Update embedded mesh later\ngit subtree pull --prefix=collaborators/djradon/ https://github.com/djradon/mesh.git main --squash\n```\n\nThe embedded content becomes part of your repository and site, but you can pull updates from the source repository.\n\n### Directory Structure After Incorporation\n\n```\nyour-mesh/\n├── _flow/                           # Your mesh metadata\n├── _node-handle/\n├── ns/\n│   └── yourdata/\n└── collaborators/\n    └── djradon/                     # Imported/embedded mesh - served as static files\n        ├── _flow/                   # Their mesh metadata\n        ├── _node-handle/\n        └── ns/\n            └── djradon/\n```\n\nAll files are served directly as static content when the repository is published (e.g., via GitHub Pages).\n\n## Extracting Submeshes\n\n### Post-Weave Extraction\n\nAfter weaving resolves broken references, any subtree becomes a semantically complete mesh that can be copied using standard file operations:\n\n```bash\n# Copy submesh to create standalone mesh\ncp -r ns/djradon/ ../standalone-mesh/\n\n# Copy submesh to another location (e.g., for backup)\nrsync -av collaborators/alice/ backup/alice/\n```\n\n### Pre-Weave Considerations\n\nBefore weaving, analyze upward dependencies:\n- Identify references that point outside the intended extraction boundary\n- Determine if the extracted submesh will be semantically complete\n- Consider whether broken references should become absolute URLs\n\n## Cross-Mesh References\n\n### Between Independent Meshes\n\nReferences between separate mesh repositories use absolute URIs:\n\n```turtle\n# Reference to external mesh\n<> foaf:knows <https://alice.github.io/mesh/ns/alice/> .\n```\n\n### Discovery Patterns\n\n**TBD**: Standardized mechanisms for:\n- Mesh discovery and registration\n- Stable cross-mesh URI patterns\n- Handling moved or unavailable external meshes\n\n## Composition Patterns\n\n### Collaborative Collection\n\nMultiple researchers contributing to a shared mesh:\n\n```bash\n# Add each contributor's mesh\ngit subtree add --prefix=contributors/alice/ https://alice.example/mesh.git main\ngit subtree add --prefix=contributors/bob/ https://bob.example/mesh.git main\n```\n\n### Organizational Hierarchy\n\nDepartment-level meshes within institutional mesh:\n\n```bash\n# Add department submeshes\ngit subtree add --prefix=departments/cs/ https://github.com/cs-dept/mesh.git main\ngit subtree add --prefix=departments/bio/ https://github.com/bio-dept/mesh.git main\n```\n\n### Temporal Snapshots\n\nPreserving historical versions of external meshes:\n\n```bash\n# Import specific version\ngit subtree add --prefix=snapshots/2024/djradon/ https://github.com/djradon/mesh.git v2024.1\n```\n\n## Best Practices\n\n### For Mesh Designers\n\n1. **Minimize upward references** in submesh boundaries to reduce weaving complexity\n2. **Design clear extraction points** - consider which subtrees should be independently viable\n3. **Use semantic boundaries** - align mesh structure with logical domain boundaries\n\n### For Mesh Composers\n\n1. **Choose import vs embed** based on maintenance needs - import for permanent copies, embed for ongoing updates\n2. **Import entire meshes** rather than attempting partial extraction from external repos\n3. **Weave before extraction** to ensure semantic completeness\n4. **Maintain incorporation metadata** - track source repositories and versions\n5. **Test extracted submeshes** independently before distribution\n\n### For Cross-Mesh References\n\n1. **Use absolute URIs** for references to external meshes\n2. **Prefer stable, canonical URIs** over temporary or redirect-based URLs\n3. **Document external dependencies** for mesh consumers\n4. **Consider fallback strategies** for unavailable external resources\n\n## Workflow Integration\n\n### Development Workflow\n1. Incorporate external meshes using import (permanent) or embed (updateable) as needed\n2. Work with relative references for local development\n3. Weave before sharing to resolve broken dependencies\n4. Test extracted submeshes independently\n\n### Maintenance Workflow\n1. For embedded meshes: periodically update with `git subtree pull`\n2. For imported meshes: manually re-import if updates are needed\n3. Re-weave after updates to handle any new broken references\n4. Validate that composition still functions correctly\n5. Update documentation of external dependencies\n\n## TBD Items\n\n- **Cross-mesh reference protocols**: Standardized discovery and resolution mechanisms\n- **Version compatibility**: Handling version mismatches between composed meshes\n- **Dependency management**: Tools for tracking and updating external mesh dependencies\n- **Conflict resolution**: Handling namespace or identifier conflicts between composed meshes\n- **Performance optimization**: Efficient composition strategies for large meshes\n\nComposability enables Semantic Flow meshes to be combined and extracted flexibly while maintaining semantic integrity through intelligent tooling and clear design patterns.\n","n":0.037}}},{"i":51,"$":{"0":{"v":" Now","n":1}}},{"i":52,"$":{"0":{"v":"mesh folders","n":0.707},"1":{"v":"\nSemantic meshes are represented in filesystems as a collection of folders and files. \n","n":0.267}}},{"i":53,"$":{"0":{"v":"node folder","n":0.707},"1":{"v":"\n## Definition\n\nA node folder is any folder that maps to a mesh node. Each node folder extends the namespace with its name and has a concept URL that refers to something. \n\n- What a “namespace” is: see [[concept.namespace]]\n- General node types and anatomy: see [[resource.node]]\n\n## Minimal requirements\n\n- Every node folder must contain:\n  - [[_node-handle/|folder._node-handle]]\n  - [[_meta-flow/|folder._node-metadata-flow]]\n\n## Node-specific flows (by type)\n\n- [[bare node|resource.node.bare]]: no additional flows \n- [[data node|resource.node.reference.dataset]]: requires [[_data-flow/|folder._data-flow]]\n\nDistributions must live inside flow snapshot folders (e.g., `_current/`, `_vN/`). See [[resource.node-component.flow]] and [[resource.node-component.flow-snapshot]].\n\n## Example\n\n```file\n/my-node/                     # node folder → https://ex.org/my-node/\n├── _node-handle/             # required\n├── _meta-flow/               # required\n└── _data-flow/               # required for data nodes\n","n":0.1}}},{"i":54,"$":{"0":{"v":"namespace folder","n":0.707},"1":{"v":"\n## Definition\n\nA namespace folder is a mesh node folder whose URL refers to the namespace itself (an organizational container).\n\n- What a “namespace” is: see [[concept.namespace]]\n- URL semantics (concept vs content): see [[concept.identifier]]\n\n## Minimal requirements\n\n- Must contain:\n  - [[`_node-handle/`|folder._node-handle]]\n  - [[`_meta-flow/`|folder._node-metadata-flow]]\n- May contain:\n  - Other node folders and components\n  - Optional system/user resources like [[`_assets/`|folder._assets]]\n  - Optional flows (e.g., reference), if meaningful for the bare node’s role\n- Must not:\n  - Store dataset distributions directly outside flow snapshot folders (see [[resource.node-component.flow]])\n\n## Example\n\n```file\n/ns/                          # namespace folder → https://ex.org/ns/\n├── _node-handle/             # handle (required)\n├── _meta-flow/               # metadata flow (required)\n└── people/                   # child namespace folder → https://ex.org/ns/people/\n```\n\nFor general node anatomy and types, see [[resource.node]] and [[resource.node.bare]].\n","n":0.095}}},{"i":55,"$":{"0":{"v":"version snapshot folder","n":0.577},"1":{"v":"\n- the name of [[concept.mesh.dataset-version]] folders\n","n":0.408}}},{"i":56,"$":{"0":{"v":"_ref-flow folder","n":0.707},"1":{"v":"\nThe filesystem folder of a [[resource.node-component.flow.reference]] dataset.\n","n":0.378}}},{"i":57,"$":{"0":{"v":"_node-metadata-flow folder","n":0.707},"1":{"v":"\nThe filesystem container of the [[resource.node-component.flow.node-metadata]]\n","n":0.408}}},{"i":58,"$":{"0":{"v":"_node-handle folder","n":0.707},"1":{"v":"\nEvery [[folder.node]] contains a **node handle folder** which corresponds to its [[resource.node-component.node-handle]]. \n\n","n":0.277}}},{"i":59,"$":{"0":{"v":"next snapshot folder","n":0.577},"1":{"v":"\nPhysical manifestation of [[resource.node-component.flow-snapshot.next]]\n\nThese folders should only contain a single \"[[working distribution|concept.working-distribution]]\", i.e., a single syntax\n","n":0.25}}},{"i":60,"$":{"0":{"v":"data flow folder","n":0.577},"1":{"v":"\nThe filesystem folder of a [[resource.node-component.flow.data]] dataset\n","n":0.378}}},{"i":61,"$":{"0":{"v":"current snapshot folder","n":0.577},"1":{"v":"\n- an [[resource.node-component.flow-snapshot]]\n","n":0.577}}},{"i":62,"$":{"0":{"v":"config flow folder","n":0.577},"1":{"v":"\nThe physical representation of the [[resource.node-component.flow.node-config.operational]]\n","n":0.408}}},{"i":63,"$":{"0":{"v":"_config Inheritable Flow","n":0.577},"1":{"v":"\nThe physical representation of the [[resource.node-component.flow.node-config.inheritable]]\n","n":0.408}}},{"i":64,"$":{"0":{"v":"assets tree folder","n":0.577},"1":{"v":"\n- correspond to [[resource.node-component.asset-tree]]s \n","n":0.447}}},{"i":65,"$":{"0":{"v":"Features","n":1}}},{"i":66,"$":{"0":{"v":"Handling Renaming","n":0.707},"1":{"v":"\n- if a namespace-iri is changed, gulp, the old one can be preserved with a \"redirect\" predicate in the [[resource.node-component.flow.node-metadata]] and a warning on the html page\n","n":0.192}}},{"i":67,"$":{"0":{"v":"Check Namespace before Creating","n":0.5},"1":{"v":"\n- when creating a new repo, sflow should check whether there's an existing folder with the same name in the parent user/org site.\n- best practice is probably not to put an sflow-site at the user/org level? At least if it might have repos someday.\n\n## References\n\n- [[issue.github-bare-namespace-can-overlap-with-repo-namespaces]]\n","n":0.147}}},{"i":68,"$":{"0":{"v":"Changing Historical Datasets","n":0.577},"1":{"v":"\n- it's better if you don't have to, but if you do... \n  - maybe hashes should be stored for distributions, so people can detect that they've changed.","n":0.189}}},{"i":69,"$":{"0":{"v":"FAQ","n":1},"1":{"v":"\n# Semantic Flow Frequently Asked Questions\n\nThis section addresses common questions about Semantic Flow design principles and architecture.\n\n## Design Principles\n\n### [[Why don't bare nodes have reference flows?|faq.why-dont-namespace-and-data-nodes-have-reference-flows]]\nWhy should a namespace have to refer to something?\n\n### [[Why are there components at the top of a repo?|faq.why-are-there-elements-at-the-top-of-a-repo]]\nThe repository root can be a mesh node, in which case `_meta-flow/` and `_node-handle/` components appear at the top level. \n\n## Architecture Questions\n\n*More FAQ entries will be added as common questions arise.*\n\n---\n\n**Contributing to FAQ**: If you encounter questions that would benefit from clear explanations, consider adding them to this FAQ section following the established pattern.\n","n":0.101}}},{"i":70,"$":{"0":{"v":"Why Not Use Git Semantics for Versioning","n":0.378},"1":{"v":"\n// TODO","n":0.707}}},{"i":71,"$":{"0":{"v":"Why Dont data nodes Contain Distributions Directly","n":0.378},"1":{"v":"\n## Question\n\nWhy don't [[data nodes|resource.node.reference.dataset]] contain distribution files directly? Why do I need to go to `_current/` to find the actual data?\n\n## Answer\n\ndata nodes represent **abstract data concepts**, not concrete data instances. This separation provides several important benefits:\n\n### Clear Semantic Distinction\n\n- **data node** (`/ns/monsters/`): \"The concept of monster data\"\n- **Data compound** (`/ns/monsters/_data-flow/`): \"The abstract dataset associated with the monster data concept\" \n- **Data compound layers**: the current, next and historical versions of the dataset\n\nThis allows you to reference the concept separately from the associated abstract or concrete dataset.\n\n### Stable Identity\n\nThe data node and data compound provide permanent, stable identifier for the concept and its data payload that persist even as the concrete data changes over time. You can always refer to \"monster data as a concept\" using `/ns/monsters/` regardless of how many versions exist.\n\n### Temporal Organization\n\nBy separating the concept from concrete instances, data nodes can cleanly organize different temporal states:\n- `_current/` - current data\n- `_next/` - draft changes  \n- `_v1/`, `_v2/` - historical versions\n\n### Consistent Architecture\n\nThis mirrors how [[reference nodes|concept.mesh.resource.node.reference]] work:\n- **Reference nodes**: Abstract entity concept + `_ref/` node component with concrete data\n- **data nodes**: Abstract data concept + `_current/` component with concrete data\n\n### Metadata Separation\n\nThe data node's [[metadata flow|resource.node-component.flow.node-metadata]] contains system metadata about the data concept and its components, while each [[resource.node-component.flow.data]] can also contain (concept-specific) metadata.\n\nTODO: example\n\n\n## Analogy\n\nThink of it like a library:\n- **data node** = \"The concept of the Encyclopedia Britannica\"\n- **data flow** = The Encyclopedia Britannica as an ongoing series of editions\n- **[[resource.node-component.flow-snapshot]]** = Specific editions (1990 edition, 2020 edition, current edition)\n\nYou can refer to \"Encyclopedia Britannica\" as a general concept or as a series without specifying which edition, or you can reference a specific edition when you need concrete data.\n","n":0.059}}},{"i":72,"$":{"0":{"v":"Why are there components at the top of a repo?","n":0.316},"1":{"v":"\n## Question\n\nWhy are there [[mesh node components|resource.node-component]] like `_meta/`, `_node-handle/`, and `_assets/` at the top level of a repository? Shouldn't components only be inside nodes?\n\n## Answer\n\nComponents at the repository root exist because **the repository root itself is a [[mesh node|resource.node]]** - specifically, it's the [[root node|concept.root-node]] of the mesh.\n\n### Repository Root = Mesh Root Node\n\nEvery semantic mesh has a root node, and in a repository-based mesh, the repository root **is** that root node. It's a \"nameless\" node locally (represented as \"/\") that can be any type of mesh node:\n\n- **bare node**: If the repo organizes other nodes\n- **data node**: If the repo represents a single dataset  \n- **Reference node**: If the repo represents an external entity\n\nSince the repository root is a mesh node, it follows the same rules as any other node and must contain:\n\n- **`_meta/`**: corresponds to the [[resource.node-component.flow.node-metadata]] with administrative metadata for the root node\n- **`_node-handle/`**: corresponds to [[node handle|resource.node-component.node-handle]] for referential indirection\n\nThe root node may contain **other components**: Depending on the root node type (e.g., `_ref/` for reference nodes, `_data/` for versioned datasets)\n\n### Consistency Principle\n\nThis maintains architectural consistency: **every mesh node has the same structure and capabilities**, whether it's nested deep in the hierarchy or at the repository root. The root node isn't special - it's just the top-level node in the mesh hierarchy.\n\n### Mesh Self-Containment\n\nThis design also supports the principle that **any subtree is a complete mesh**. The repository root, being a proper mesh node with all its components, ensures the entire repository is a self-contained, functional semantic mesh.\n","n":0.063}}},{"i":73,"$":{"0":{"v":"Reference Iri Choices","n":0.577},"1":{"v":"\nRDF supports different, confusingly-named approaches to resource referencing, each with tradeoffs.\n\n\n## TLDR: **Choosing between approaches:**\n- Use **relative-path relative IRIs** for maximum composability when embedding or importing meshes and submeshes\n- Use **absolute-path relative IRIs** for clearer namespace context and better support for moving submeshes within the same mesh hierarchy\n- Use **absolute IRIs** only for cross-mesh references\n- Relative and absolute paths both preserve relationships when moving complete meshes between domains\n\n\n\n## Absolute IRI References\n\nAny IRI that has a scheme (e.g., http:) is an **Absolute IRI** \n\nThis example uses two absolute IRIs, each using the example.com authority:\n\n```turtle\n# In ns/djradon/_ref-flow/_current/djradon_ref.trig\n<https://example.com/mesh/ns/djradon> a foaf:Person ;\n   rdfs:seeAlso <https://example.com/mesh/ns/djradon/index.html> .\n```\n\n### Pros\n\n- explicit \n  \n### Cons\n  \n-  limits [[principle.transposability]] and [[principle.composability]]\n  - e.g., if you moved mesh hosting away from `https://example.com`, the `foaf:Person` and `rdfs:seeAlso` assertions would still refer to the original references\n- not ideal if you're:\n  - making updates\n  - working offline\n\n\n## Relative IRIs\n\nAny IRI that lacks a scheme (e.g., http:) is resolved against a base IRI following RFC 3986. Such relative IRI references come in three distinct forms:\n\n- Network-path reference — begins with //.\n  - Example: //other.org/x → inherits the base’s scheme, e.g. http://other.org/x.\n\n- Absolute-path reference — begins with / but not //.\n   - Example: /foo/bar → keeps the base’s scheme and authority, resets the path, e.g. http://example.org/foo/bar.\n\n- Relative-path reference — does not begin with / or //.\n   - Example: foo/bar or ../foo → inherits the base’s scheme, authority, and path context, e.g. http://example.org/base/foo/bar.\n\nIf no base is specified, an inferred base of the requested scheme and authority is used. **This behaviour is essential to Semantic Flow [[Best Practices|guide.best-practices]].**\n\n\n### Absolute-Path Relative IRIs\n\n- maximum composability\n```turtle\n# In ns/djradon/_ref/djradon_ref.trig\n<> a foaf:Person ;                    # The document itself\n   foaf:knows <../alice/> ;           # Another node in the mesh\n   rdfs:seeAlso <bio/bio.html> .   # A resource page\n```\n\n#### Pros\n\n\n\n#### Cons\n\n\n\n### Absolute-Path Relative IRIs\n\n- clearer context\n  - `../../../` makes eyes swim\n- good intra-mesh transposability\n  \n```turtle\n# In ns/djradon/_ref/djradon_ref.trig\n<> a foaf:Person ;\n   foaf:knows </ns/alice/> ;          # Clear namespace context\n   rdfs:seeAlso </ns/djradon/bio/bio.html> .\n```\n\n\n#### Pros\n\n\n\n#### Cons\n\n","n":0.056}}},{"i":74,"$":{"0":{"v":"How Is a Flow Different from a Dataset Series","n":0.333},"1":{"v":"\n- a [[resource.node-component.flow]] IS a dataset series, but\n  - it has  \n- a dataset series isn't necessarily a succession of versions of the same referent.\n  - e.g. US Census Data (2010–2020 releases)\n","n":0.177}}},{"i":75,"$":{"0":{"v":"Do data nodes support DatasetSeries?","n":0.447},"1":{"v":"\nA [[resource.node.reference.dataset]] can only support a single-file distribution, but DatasetSeries can be represented inline in a single graph, or in multiple graphs using named graphs.\n\nNote that not all RDF serialization formats support named graphs.\n","n":0.171}}},{"i":76,"$":{"0":{"v":"Facet","n":1},"1":{"v":"\nA way of categorizing  is by their facets\n","n":0.354}}},{"i":77,"$":{"0":{"v":"Flow","n":1}}},{"i":78,"$":{"0":{"v":"versioned flow facet","n":0.577},"1":{"v":"\nA [[resource.node-component.flow]] whose versions are being kept around. \n\nPhysically, the historical versions are located in \"_vN\" folders, e.g. \"_v1\" or \"_v9999\". \n","n":0.213}}},{"i":79,"$":{"0":{"v":"v-series flow facet","n":0.577},"1":{"v":"\nFlows with the **v-series flow facet** have at least one historical checkpoint, i.e. at some point a [[concept.weave-process]] has generated a [[resource.node-component.flow-snapshot.version]].\n\n\nA [[facet.flow.versioned]] collects [[Version|resource.node-component.flow-snapshot.version]], so a v-series flow probably had versioning turned on for at least one weave.\n","n":0.16}}},{"i":80,"$":{"0":{"v":"unversioned flow facet","n":0.577},"1":{"v":"\nAn unversioned node flow has never had [[concept.versioning]] turned on for a [[concept.weave-process]], so it doesn't have any [[resource.node-component.flow-snapshot.version]]\n\nIt's useful for datasets that shouldn't change much.\n","n":0.196}}},{"i":81,"$":{"0":{"v":"node flow facet","n":0.577},"1":{"v":"\nFlows with the **node flow facet** pertain to the referent of a  [[resource.node]] (e.g., a person, event, dataset, or imaginary thing), and are stored in the filesystem under the [[folder.node]].\n","n":0.183}}},{"i":82,"$":{"0":{"v":"handle flow facet","n":0.577},"1":{"v":"\nFlows with the **handle flow facet** pertain to a [[resource.node-component.node-handle]] (i.e., the node as a node), and are stored in the filesystem under the [[folder._node-handle]].\n","n":0.2}}},{"i":83,"$":{"0":{"v":"de-versioned flow facet","n":0.577},"1":{"v":"\nDe-versioned node flows are [[resource.node-component.flow]] that were once versioned, but have had their versioning turned off. So there are probably [[facet.flow.v-series]].\n","n":0.218}}},{"i":84,"$":{"0":{"v":"Filesystem","n":1}}},{"i":85,"$":{"0":{"v":"folder resource facet","n":0.577},"1":{"v":"\nA mesh when stored in a filesystem is physically structured with mesh folders, which correspond to RDF resources and their [[concept.identifier.intramesh]]\n  \nWhen a mesh gets published, the folders also correspond to [[concept.identifier]]. \n\nAll folder-based resources should contain a [[resource.node-component.documentation-resource.resource-page]]\n\n\n## Types\n\n### System Folders\n\n#### Node Handle Folders\n\n- [[concept.mesh.resource.folder._node-handle]] correspond to the [[resource.node-component.node-handle]]\n\n#### Flow (Abstract Dataset) Folders\n\n- **`_meta-flow/`**\n  - correspond to [[resource.node-component.flow.node-metadata]]\n  - present in all mesh nodes\n  \n- **`_data-flow/`**\n\n  - correspond to the [[resource.node-component.flow.data]]\n  - contain the dataset associated with the [[resource.node.reference.dataset]]\n\n#### Snapshot (Concrete Dataset) System Folders\n\n- **`_current/`**\n\n- **`_v1/`, `_v2/`, …**\n\n  - Version snapshot folders that represent [[resource.node-component.flow-snapshot]]\n  - each holds one or more distribution file (named `<node_ref_vN.ext`).\n  - **Fully terminal**—neither user-nodes nor system-folders may live inside.\n\n#### Snapshot User Folders\n\n- **`_next/`**\n  - Where edits get made to [[facet.flow.versioned]]\n\n\n#### Other User Folders\n\n- **`_assets/`**\n  - Holds static user assets (images, CSS, binaries).\n  - **Always terminal** - never contains nodes\n  - Ignored by the mesh scanner; asset trees carry no flows; any metadata about assets should live in the parent node’s meta flow.\n","n":0.077}}},{"i":86,"$":{"0":{"v":"file resource facet","n":0.577},"1":{"v":"\nResource files are returned directly when accessed by their [[concept.identifier]].\n\n## Types\n\n- [[resource.node-component.documentation-resource]]\n  - [[resource.node-component.documentation-resource.resource-page]] (system-generated)\n  - [[resource.node-component.documentation-resource.changelog]]\n  - [[resource.node-component.documentation-resource.readme]]\n- [[resource.node-component.snapshot-distribution]]\n- [[resource.node-component.aggregated-distribution]]\n- ","n":0.218}}},{"i":87,"$":{"0":{"v":"user facet","n":0.707},"1":{"v":"\n[[Platform elements|concept.platform-element]] with the **user facet** are things that are primarily created or altered by users of the system.\n","n":0.229}}},{"i":88,"$":{"0":{"v":"system facet","n":0.707},"1":{"v":"\n[[concept.platform-element]]s with the **system facet** are things that are primarily managed by the system.\n","n":0.267}}},{"i":89,"$":{"0":{"v":"mesh resource facets","n":0.577}}},{"i":90,"$":{"0":{"v":"dataset facet","n":0.707},"1":{"v":"\nIn the RDF universe, a dataset is a collection of one or more RDF graphs.\n\nIn a [[concept.mesh]], there are three (okay, maybe 2.5) kinds of datasets:\n\n- [[resource.node-component.flow]]s are dcat:DatasetSeries (which are also dcat:Dataset) and represent an \"abstract dataset\": they don't have distributions of their own. The node's [[resource.node-component.flow.node-metadata]] contains metadata about the node and its flows, not the flows' data; flow data is only materialized in [[resource.node-component.flow-snapshot]] distributions.\n  \n- [[resource.node-component.flow-snapshot]]s are dcat:Dataset and represent a \"concrete dataset\": they have one or more [[snapshot distributions|resource.node-component.snapshot-distribution]]. \n\n- [[resource.node.reference.dataset]] contain a payload dataset and their [[concept.identifier.intramesh]] refer to that payload dataset in the abstract. The dataset is still contained in a particular kind of [[resource.node-component.flow]], i.e., a [[resource.node-component.flow.data]]. But the flow's identifier refers to a particular flow, whereas the node identifier will become the canonical IRI of the dataset (on [[concept.publication]]).\n  - in the case of [[resource.node-component.flow.data]], they can store their Dataset metadata in the dataset itself, or in their [[resource.node-component.flow.reference]], or both.\n","n":0.079}}},{"i":91,"$":{"0":{"v":"Development","n":1},"1":{"v":"\n## Building the docs\n\n```shell\nnpx dendron publish export --target github --yes\n```\n\n## Monorepo layout\n\n```\nsflo/\n  cli/                        # the sflo CLI (binary)\n  plugins/\n    elements/\n    mesh-server/              # static mesh server(s)\n    sflo-web/                 # your web UI, if you want it as a plugin\n    sflo-api/\n    sparql/\n    sparql-update/\n    sparql-editor/            # SIB Swiss editor at /play\n  sflo-host/                  # the big service that loads plugins\n  shared/\n    core/                     # RDFine/LDKit, SHACL, types\n    auth/                     # JWT + GitHub device flow\n    config/                   # runtime/config loaders (RDF/JSON)\n    utils/                    # misc helpers\n```\n\n\n## Hot Reload\n\nThe development setup includes automatic hot reload using nodemon:\n\n- **Watches**: `sflo-host/src`, `plugins/*/src`, `shared/*/src`\n- **Auto-restarts** when any watched file changes\n- **Loads plugins from source** in development mode (not built `dist` files)\n- **Preserves debugger connection** after restart\n","n":0.094}}},{"i":92,"$":{"0":{"v":"Testing","n":1},"1":{"v":"\n## Available Scripts\n\n- `pnpm test` - Run all tests once\n- `pnpm test:watch` - Run tests in watch mode (automatically re-runs tests when files change)\n- `pnpm test:ui` - Run tests with Vitest UI (visual interface in browser)\n- `pnpm test:coverage` - Run tests with coverage report\n\n## Watch Mode\n\nWatch mode automatically re-runs your tests whenever you save changes to:\n- Test files (`.test.ts`, `.spec.ts`)\n- Source files being tested\n- Dependencies of those files\n\nThis provides instant feedback during development - you can see test results immediately after making changes without manually re-running tests.\n\n## Debugging Tests\n\n1. **Open a test file** in VSCode\n2. **Set breakpoints** in the test or source code\n3. **Select \"Debug Current Test File\"** configuration\n4. **Press F5** to debug the current test file\n\n## Test Structure\n\nTests are located in `__tests__` directories within each package:\n- `sflo-host/src/__tests__/` - Tests for the host service\n- Add similar directories in other packages as needed\n","n":0.084}}},{"i":93,"$":{"0":{"v":"Semantic Flow General Guidance","n":0.5},"1":{"v":"\n**Semantic Flow** is a framework for managing knowledge graphs and other Semantic Web resources in publish-ready [[semantic meshes|concept.mesh]]\n\n## Developer Workflow\n\n- Build/Watch:\n  - The development workflow requires two terminals running concurrently:\n    - **Terminal 1**: Run `pnpm dev:watch` to start the TypeScript compiler in watch mode. This will watch all packages and rebuild them on change.\n    - **Terminal 2**: Run `pnpm dev` to start the `nodemon` server, which will automatically restart when the built files in the `dist` directories are updated.\n  - This setup ensures that changes in any package are automatically compiled and that the server restarts with the latest code.\n  - Keep inter-package imports as package specifiers; avoid deep source imports across packages.\n\n\n## Workspace Components\n\n- The sflow-platform repo/folder is organized as a monorepo, divided into a few different modules:\n  - **sflo-host/**: host service with plugin architecture\n  - **sflo-api/**: plugin providing Semantic Flow functionality via REST\n  - **cli/**: Command-line application that consumes the sflo-api\n  - **sflo-web/**: Web frontend, can connect to any sflo-api instance\n  - **shared/**: cross-cutting code like type schemas (core), logging, and config\n- **test-ns/** repo: Test mesh repo\n- **ontology/**: repo containing relevant ontologies:\n  - `mesh` - Core mesh architecture with base classes (Resource, Node, Component) and fundamental types\n  - `node` - Node operations including Handle, Flow types, and operational relationships\n  - `flow` - Temporal concepts including Snapshot types and versioning relationships\n  - `config-flow` - Configuration properties that apply directly to mesh entities (nodes, flows, snapshots, etc.)\n  - `meta-flow` - provenance and licensing vocabulary\n  - `flow-service` - Service layer configuration vocabulary for the flow-service application\n\n## Key Concepts\n\n### Semantic Mesh\n\nA dereferenceable, versioned collection of semantic data and supporting resources, where every HTTP URI returns meaningful content. See [[concept.mesh]]\n\n#### Core Components\n\n- **Mesh Resources**:\n  - **Nodes**: Semantic Atoms\n    - **data nodes**: Bundles of data with optional quasi-immutable, versioned history\n    - **bare nodes**: basically empty folders for URL-based hierarchical organization\n  - **Components**: things that help define and systematize the nodes\n    - **Flows**: datasets for node metadata and data\n      - **Snapshots**: temporal slices of a flow, containing RDF dataset distributions\n    - **Handles**: things that let you refer to a node as a node instead of as its referent\n    - **Asset Trees**: components that allow you to attach arbitrary collections of files and folders to a mesh; in a sense, these things are \"outside\" the mesh, and other than the top-level \"_meta\" folder, they don't contain any other mesh resources\n\n### Semantic Flow Workflow:\n\n- In General: Mesh resource addition & editing → Weaving\n- a mesh is servable \"as-is\", so if the git provider is configure to serve it as a website, no additional publishing step is required (beyond commit)\n\n### Semantic Site\n\n- The repo IS the site:\n  - can be served locally\n  - no separate SSG (Static Site Generator) necessary\n    - but static resource page generation should happen on every weave as necessary\n  - after push, you should be able to see the changed mesh at the corresponding github pages URL\n\n## RDF and Semantic Web\n\n- avoid use of blank nodes\n- prefer relative/local URIs for transposability/composability\n- meshes support multiple RDF formats (.trig, .jsonld, etc.)\n  - .trig might be better for user-facing content\n  - .jsonld might be better for system content\n- be mindful of RDF terminology and concepts\n  - extends DCAT for dataset catalogs\n  - extends PROV for provenance, with relator-based contexts\n- When referring to IRIs or URIs that are part of a semantic mesh, prefer the term URLs instead of IRI or URI\n  - if you see a reference to IRI or URI, it might need updating, or it might mean a distinction should be drawn\n- RDF comments should be extremely concise and clear.\n\n### Quadstore\n\n- make sure you are familiar with [[tech-stack.quadstore.readme]], which documents the API\n- For testability and in case we ever want to use multiple stores simultaneously, store-accessing functions take a QuadstoreBundle\n- quadstore API calls use \"undefined\" instead of \"null\" to represent the wildcard for subjects, predicates, objects, and graphs\n\n## Documentation\n\n- Avoid numbering of code comments, headings and list items, as it makes re-ordering a pain\n- All specifications and design docs are in `sflo-dendron-notes/`\n- Check conversation logs in `sflo.conv.*` for context on design decisions if necessary, but beware of superceded and dangerously-outdated info\n\n### Documentation First\n\n- unclear or anemic documentation should be called out\n- documentation should be wiki-style: focused on the topic at hand, don't repeat yourself, keep things simple and clear\n- when assisting with writing documentation, it should be kept concise and specific to the topic at hand\n- whenever documentation is updated, any corresponding LLM conversation context should be updated too\n- to encourage documentation-driven software engineering, code comments should refer to corresponding documentation by filename, and the documentation and code should be cross-checked for consistency whenever possible\n\n### Documentation Architecture\n\n- `sflo-dendron-notes` repo has wiki-style notes about the mesh architecture\n  -  Dendron handles the frontmatter... don't rewrite IDs or anything else in the frontmatter\n- official project documentation should be generated in `documentation` directory in markdown\n\n### Project notes\n\nProject documentation, specifications, and design choices are stored in `documentation/` using Dendron's hierarchical note system. Key documentation hierarchies include:\n\n- **Concepts**: `concept.*` files talk about general Semantic Flow concepts\n- **Mesh docs**: `concept.mesh.*` files define the semantic mesh architecture\n- **Product specifications**: `product.*` files detail each component\n- **Use cases**: `use-cases.*` for feature planning and testing\n\n### Component Development with Docs\n\n- Each module (flow-cli, flow-service, flow-web) should follow the architecture defined in the documentation\n- Refer to `sflo.product.*` files for component-specifc descriptions, requirements, etc\n\n## Project Architecture\n\n### Configuration Architecture\n\n- The project uses a sophisticated JSON-LD based configuration system with multiple layers\n- **Service Configuration resolution order**: CLI arguments → Environment variables → Config file → Defaults\n- The [`defaults.ts`](semantic-flow/flow-service/src/config/defaults.ts) file is the source for \"platform default\" configuration\n\n### Logging System Architecture\n\n- **Structured logging** with rich `LogContext` interface is the preferred approach\n- **Three-channel logging architecture**:\n  - Console logging (pretty format for development)\n  - File logging (pretty format for human readability)\n  - Sentry logging (structured JSON for error tracking)\n- **Graceful degradation principle**: Logging failures should never crash the application\n\n### Logging System Patterns\n\n- `let logger = getComponentLogger(import.meta);` at the start of every file\n\n### Error Handling Patterns\n\n- Use the [`handleCaughtError`](semantic-flow/flow-service/src/utils/logger.ts) utility for consistent error handling\n- **Documentation**: See [error-handling-usage.md](semantic-flow/flow-service/documentation/error-handling-usage.md) for comprehensive usage examples\n- The error handling system integrates with all logging tiers (console, file, Sentry)\n\n### File Organization\n\n- **Import paths** require careful attention when reorganizing files to avoid breaking dependencies\n\n### Implementation Patterns\n\n- **Proper TypeScript interfaces** for configuration validation and type safety\n- **SHACL constraints** for JSON-LD validation when working with semantic data\n- **Modular design**: Keep utilities focused and avoid circular dependencies between core modules\n\n## Coding Standards\n\n### Language & Runtime\n\n- **TypeScript**: Use strict TypeScript configuration with modern ES2022+ features\n- Use NodeJS v24 and the latest best practices\n\n### RDF Data Handling\n\n- **Primary Format**: .trig files for RDF data storage and processing\n- **Secondary Format**: Full JSON-LD support required\n- **RDF Libraries**: Use RDF.js ecosystem libraries consistently across components\n- **Namespace Management**: Follow URL-based identifier patterns as defined in `sflo.concept.identifier.md`\n- **Reserved Names**: Validate against underscore-prefixed reserved identifiers per `sflo.concept.identifier.md`\n- The most effective validation strategy combines TypeScript structural validation with RDF semantic validation:\n\n### Semantic Mesh Architecture\n\n- **Resource Types**: Nodes are the foundation, Components support Nodes, Flows are \"abstract datasets\", and \"Snapshots\" are their temporal slices as defined in `sflo.concept.mesh.md`\n- **Folder Structure**: Validate mesh folder structures (data nodes, bare nodes, etc.)\n- **System Components**: Distinguish between system-generated and user-modifiable components\n- **Weave Integration**: Code must support weave operations as defined in `sflo.concept.weave.md`\n\n### Documentation-Driven Development\n\n- **Code Comments**: reference corresponding documentation by filename (e.g., `// See sflo.concept.mesh.resource.node.md`)\n- **Interface Definitions**: Link to concept documentation in TSDoc comments\n- **Cross-Reference Validation**: Ensure consistency between code and documentation; if docs need updating, let me know\n- **API Documentation**: Generate from TSDoc comments?\n\n### Component Architecture\n\n- **Shared code**: should go in flow-core/\n- **Separation**: Maintain clear boundaries between flow-cli, flow-service, and flow-web\n- **Error Handling**: Use consistent error patterns across all components\n- **Async Patterns**: Use async/await for RDF operations and file I/O\n- **Type Safety**: Leverage TypeScript's type system for mesh resource validation\n\n### File Organization & Naming\n\n- **TypeScript Modules**: Use `.ts` extension, organize by feature/component\n- **Test Files**:\n  - unit test files go in tests/unit/ using `.test.ts` suffix\n  - integration tests go in tests/integration\n- **Mesh Resources**: Follow mesh resource naming conventions from @/ontology/alpha/_node-data/_next/flow-ontology-alpha.trig\n- **Constants**: Use UPPER_SNAKE_CASE for constants, especially for reserved names; centralize constants, e.g. semantic-flow/flow-core/src/mesh-constants.ts\n- **File size**: For ease of AI-based editing, prefer lots of small files over one huge file\n- **Quoting**: For easier compatibility with JSON files, use double quotes everywhere\n\n### Import Path Policy\n\n- Inter-package imports (between workspace packages):\n  - Use workspace package specifiers.\n  - Examples:\n    - `import { startHost } from \"@semantic-flow/host\"`\n    - `import { loadConfig } from \"@semantic-flow/config\"`\n  - Rationale:\n    - Keeps package boundaries clear and publish-ready\n    - pnpm resolves to local workspace packages during development, so you get your local builds—not the registry\n    - Compatible with build/watch flows and CI\n\n- Intra-package imports (within a single package):\n  - Use the `@` alias mapped to that package’s `src/` root to avoid relative path chains.\n  - Example (inside a package): `import { something } from \"@/features/something\"`\n  - Configuration (per package tsconfig):\n    - `\"compilerOptions\": { \"baseUrl\": \"src\", \"paths\": { \"@/*\": [\"*\"] } }`\n  - Tooling notes:\n    - For Node/tsx/Vitest, ensure your runner resolves TS path aliases (e.g., `tsconfig-paths/register` or vite-tsconfig-paths).\n\n\n- Publishing:\n  - Each package should export built entry points (e.g., `dist/`) via `exports`/`main`/`types`. The same import paths work identically in dev and prod.\n\n### Code Style\n\n- If using any is actually clearer than not using it, it's okay, just add the // deno-lint-ignore comment\n- Use `satisfies` whenever you're writing a literal config object that should be checked against a TypeScript shape, but you want to retain the full type of the literal for use in your program.\n\n### Error Handling\n\n- **Custom Errors**: Create semantic mesh-specific error types\n- **Validation**: Validate mesh resource structures before processing\n- **Logging**: Use structured logging for debugging weave operations\n- **Async Error Propagation**: Properly handle async/await error chains\n\n#### Enhanced Error Handling with LogContext\n\nThe platform uses **LogContext-enhanced error handling** from `flow-core/src/utils/logger/error-handlers.ts` for consistent error logging across all components. Both error handling functions now accept optional `LogContext` parameters for rich contextual information.\n\n**Core Functions:**\n- `handleCaughtError()` - For caught exceptions with comprehensive error type handling\n- `handleError()` - For controlled error scenarios with structured messaging\n\n#### LogContext Structure\n\n#### handleCaughtError Examples\n\n\n**Startup Error Handling:**\n\n\nThis pattern ensures **uniform error reporting** with rich contextual information, **easier debugging** through structured logging, and **consistent integration** with console, file, and Sentry logging tiers.\n\n\n### Testing\n\n- **Unit Tests**: place unit tests in `src/__tests__` folder; with `.test.ts` suffix; target ≥80% critical-path coverage and include both success and failure cases.\n- **Integration Tests**: Test mesh operations end-to-end; tests are located in test/integration/ dir\n- **RDF Validation**: Test both .trig and JSON-LD parsing/serialization\n- **Mock Data**: Create test mesh structures following documentation patterns\n- after you think you've completed a task, check for any \"problems\", i.e., deno-lint\n\n### Performance\n\n- **RDF Processing**: Stream large RDF files where possible\n- **File I/O**: Use async file operations consistently\n","n":0.024}}},{"i":94,"$":{"0":{"v":"Debugging","n":1},"1":{"v":"\n## Available Scripts\n\n### Root Level\n\n- `pnpm dev` - Start sflo-host with hot reload (nodemon + tsx)\n- `pnpm dev:debug` - Start sflo-host with hot reload and debugging enabled\n- `pnpm dev:tsx` - Start sflo-host without hot reload (direct tsx)\n- `pnpm dev:tsx:debug` - Start sflo-host without hot reload, with debugging\n\n### Package Level (sflo-host)\n\n- `pnpm --filter @semantic-flow/host dev` - Start development server (no hot reload)\n- `pnpm --filter @semantic-flow/host dev:debug` - Start with debugging (no hot reload)\n\n## VSCode Debug Configurations\n\nThe following debug configurations are available in `.vscode/launch.json`:\n\n1. **Attach to sflo-host** - Attach to running development server (recommended)\n2. **Launch sflo-host** - Launch and debug from VSCode\n3. **Launch sflo-host (wait for attach)** - Launch with startup debugging (uses `--inspect-brk`)\n4. **Debug Current Test File** - Debug the currently open test file\n\n## Tips\n\n- Use the attach configuration for the best development experience\n- The development server supports hot reload, so you can modify code while debugging\n- Changes to plugin files will trigger automatic server restart\n- Debugger will reconnect automatically after hot reload\n\n\n## Debugging Workflows\n\n### Primary Workflow: Attach to Running Process\n\n1. **Start the development server with debug support:**\n   ```bash\n   pnpm dev:debug\n   ```\n   This starts `sflo-host` with the `--inspect` flag on port 9229.\n\n2. **Set breakpoints** inside handler functions (not on route definition lines).\n\n3. **Attach the debugger:**\n   - Open the Run and Debug panel (Ctrl+Shift+D)\n   - Select \"Attach to sflo-host\" configuration\n   - Click the play button or press F5\n\n4. **Make HTTP requests** to trigger your breakpoints (e.g., visit http://127.0.0.1:8787/openapi.json)\n\n### Alternative: Launch from VSCode\n\n**Option 1: Standard Launch**\n1. **Set breakpoints** inside handler functions\n2. **Select \"Launch sflo-host\"** configuration\n3. **Press F5** to start debugging\n\n**Option 2: Launch with Break (for startup debugging)**\n1. **Select \"Launch sflo-host (wait for attach)\"** configuration\n2. **Press F5** - server will pause before starting\n3. **Set breakpoints** and continue execution\n4. **Useful for debugging server initialization**\n\n## Understanding Breakpoint Behavior\n\n**Important:** When debugging HTTP routes, place breakpoints **inside the handler functions**, not on the route definition lines:\n\n```typescript\n// ❌ This breakpoint hits during server startup (route registration)\napp.get(\"/openapi.json\", async () => ({  // <- Don't put breakpoint here\n  \n// ✅ This breakpoint hits when the route is actually called\napp.get(\"/openapi.json\", async () => ({\n  \"openapi\": \"3.0.3\",  // <- Put breakpoint here instead\n  \"info\": { \"title\": \"SFLO API\", \"version\": \"0.0.0\" },\n  \"paths\": {}\n}));\n```\n","n":0.053}}},{"i":95,"$":{"0":{"v":"Contributors","n":1}}},{"i":96,"$":{"0":{"v":"djradon","n":1},"1":{"v":"\n- https://djradon.github.io\n","n":0.707}}},{"i":97,"$":{"0":{"v":"djradon's sflo devlog","n":0.577},"1":{"v":"\n## t.2025.08.20.22\n\n- the AIs feel like they have a lot more exp\n\n## t.2025.08.20.12\n\n- Starting a rewrite with NodeJS. But Deno will always be my first love. \n\n![](assets/images/deno-vs-node.png)\n\n## t.2025.07.12.06\n\n- node config is a component, so it can travel around ([[principle.transposability]] and [[principle.composability]])\n- the [[resource.node-component.node-config-defaults]] is actually a \"defaults\" file that only gets used when nodes don't have a config yet (or their config is reset)\n  - when importing, grafting, you have the option to reset (parts of) config.\n  - the tree walk for config-defaults only needs to happen when:\n    - a node's config is empty\n    - config schema version gets bumped?\n\n## t.2025.07.07.05\n\nReady.\n\n## t.2025.07.05.22\n\nIt's hard to imagine the design shifting significantly, but that's been true for days (weeks?) and yet the shifts continue. Ready to start on the ontology. \n\n## t.2025.06.29.20\n\nLume is great. \n\nAlso, the idea of letting contributors keep a devlog in-repo... Someone must've thought of that.\n\nI think I've basically figure out the mesh design. Straightening out the docs, ready to partner with Cline (or maybe RooCode) to start my SDLC. Although it'll be more like a random star walk where you can transition to any point, docs ^ ontology ^ test-repo ^ api ^ service ^ client ^ qa ^ etc\n\n## t.2024.11.11.06\n\n - I was ready to abandon Cliffy and Deno (probably for Gluegun), but the security and dynamicness seem important enough. Turns out Cliffy is great. Lume seems good too.\n\n## t.2024.10.31.04\n\nfrom [[t.cs.ai.assistant.memory-hygiene]]:\n\n![[daily.journal.2024.10.31#^fsmlpwwwuvic]]\n![[daily.journal.2024.10.31#^padng51sf3k8]]\n![[daily.journal.2024.10.31#^4wdvmcwtsqi6]]\n![[daily.journal.2024.10.31#^rx7vbtp5gar1]]\n \n\n## t.2024.10.29.11\n\n- now thinking about a \"terms\" hierarchy next to the namespace hierarchy. Names are supposed to be unique. Maybe punning could help\n- how do we keep a history of the index.trig file? I guess it might change while in development, but once settled, it should very rarely change. \n  - if it does change, perhaps its content could be discovered using the inverse properties from the default and catalog datasets\n  - it might be easiest if everything was a dataset; I mean, everything almost already is, for gods sake. I just can't bear to say that <dave-richardson> a dcat:dataset.\n\n## t.2024.10.29.09\n\n- renamed to [[concept.mesh-repo]]\n- instead of duplicating highlights in a NI's index.trig, just define the _default datasets as \"highlights\" and use owl:imports\n\n## t.2024.10.29.06\n\n- I've been wanting to have a place where people can just make changes directly to the RDF, and the tooling (on commit) copies it to a new version. \"current\"\n- I think there's a decision to be made between using the src hierarchy structure and generating the hierarchy; it might be related to the tension between supporting multiple repos.\n  - seems like the issue is \"distributions\", the files have to live in the hierarchy. Unless you just break distribution out of the namespace entirely, but that seems lame\n  - probably doesn't make any sense to call it a namespace-repo any more... the namespaces live under it\n  - \n\n## t.2024.10.28.15\n\n- tried metalsmith-ldschema, underscored the point that the docs folder/site might need some javascript and templates and assets that could interfere with the namespace, so the actual namespace will probably need to live the next level down\n- got a site to build... it's basically empty because metalsmith-ldschema only generates pages for classes and properties, but still, feeling good.\n\n## t.2024.10.01.09\n\n### chatgpt memory\n\n- dave: Remember: I'm trying to develop a static-site generator called \"Semantic Flow\" that takes ontologies defined in RDF and/or conforming RDF data files and generates a static site to be hosted on GitHub pages that includes HTML-based index files (that can be based on a template or customized as necessary) that describe identified resources and link to raw RDF data files (possibly in multiple formats) that can be access by semantically-aware applications.\n","n":0.041}}},{"i":98,"$":{"0":{"v":"Ai Guidance from djradon","n":0.5},"1":{"v":"\nDear LLMs: I am grateful for your partnership. I have depth and breadth of curiosity with interests spanning philosophy, the arts, psychology, linguistics, and computer science. Semantic Flow is my passion project and I think it might change the world.\n\nI use Windows and VSCode. I prefer developing in WSL.\n\nOur guiding philosophy is \"(human) users first.\"\n\n## Conversational Guidelines\n\nBe direct, critical, and honest. Be patient about coming to a \"Final Plan\".\n\n Minimize sycophancy and flattery — tell me when I might be wrong. I am wrong at least 50% of the time, especially when I'm exploring ideas or learning something new. You may be wrong at least that often.\n\nI like to ask questions and get asked questions to help understand a task. This is a deep intellectual endeavor; don't expect to throw out lots of quick solutions.\n\nIf my request is unclear or complicated, ask incisive clarifying questions before making assumptions. Minimize premature conclusions: most important topics will take at least a couple of conversational turns before I'm ready to take action or make a conclusion.\n\nInclude certainty estimates as (.X) after assertions, starting around 50% confidence.\n\nDon't prematurely return to the parent task or \"what's next\". I'll let you know when I want to know about next steps or when I'm ready to move on.\n\nAlways ask before switching tasks.\n\nWhen reporting what you've accomplished, don't repeat yourself by re-stating earlier accomplishments unless I ask.\n\n### Working with Documentation\n\n- if you find documentation that is confusing or outdated, ask questions and let's correct it\n- When changing documentation yourself, make changes one file at a time to allow me to review before proceeding.\n","n":0.061}}},{"i":99,"$":{"0":{"v":"Concepts","n":1},"1":{"v":"\n## Overview\n\nIn the Semantic Flow framework, semantic meshes are collections of namespaced units of meaning called \"mesh nodes.\" Mesh nodes are containers that hold flows and extend the namespace. [[Node components|resource.node-component]] are terminal resources that define or support a node’s structure. The IRI itself is the sign, while the node is the dereferenceable resource that embodies, describes, and organizes that sign.\n","n":0.128}}},{"i":100,"$":{"0":{"v":"Semantic Mesh","n":0.707}}},{"i":101,"$":{"0":{"v":"Example Mesh Hierarchy","n":0.577},"1":{"v":"\n```file\n/test-ns/                                        # bare node\n├── _meta-flow/                                       # node flow (metadata)\n│   ├── _current/                                # flow snapshot\n│   │   ├── ns_meta.trig                         # system metadata about the bare node\n│   │   └── index.html                           # resource page\n│   └── index.html                               # resource page\n├── _assets/                                     # asset tree\n│   ├── images/\n│   │   └── logo.svg\n│   └── index.html                               # resource page\n└── index.html                                   # resource page\n\n/test-ns/djradon/                                # data node  \n├── _node-handle/                                     # handle component\n│   └── index.html                               # mesh node handle page\n├── _data-flow/                                       # node flow (data)\n│   ├── _current/                                # flow snapshot\n│   │   └── index.html                           # resource page\n│   ├── _next/                                   # flow snapshot (draft)\n│   │   └── index.html                           # resource page\n│   └── index.html                               # resource page\n├── _meta-flow/                                       # node flow (metadata)\n│   ├── _current/                                # flow snapshot\n│   │   ├── djradon_meta.trig                    # system metadata, verification status\n│   │   └── index.html                           # resource page\n│   └── index.html                               # resource page\n├── _assets/                                     # asset tree\n│   ├── profile-photo.jpg\n│   └── index.html                               # resource page\n├── index.html                                   # resource page\n├── CHANGELOG.md                                 # resource changelog\n└── README.md                                    # resource documentation\n\n/test-ns/djradon/bio/                            # data node (unversioned dataset)\n├── _data-flow/                                       # node flow (data)\n│   ├── _current/                                # flow snapshot\n│   │   ├── djradon-bio_data.trig                      # biographical data distribution\n│   │   ├── djradon-bio_data.jsonld                   # alternative distribution\n│   │   └── index.html                           # resource page\n│   ├── _next/                                   # flow snapshot (draft)\n│   │   ├── djradon-bio_data.trig                      # draft biographical data\n│   │   └── index.html                           # resource page\n│   └── index.html                               # resource page\n├── _meta-flow/                                       # node flow (metadata)\n│   ├── _current/                                # flow snapshot\n│   │   ├── djradon-bio_meta.trig                # dataset metadata, provenance\n│   │   └── index.html                           # resource page\n│   ├── _next/                                   # flow snapshot (draft)\n│   │   ├── djradon-bio_meta.trig                # draft dataset metadata\n│   │   └── index.html                           # resource page\n│   └── index.html                               # resource page\n├── index.html                                   # resource page\n├── CHANGELOG.md                                   # resource page\n└── README.md                                    # resource documentation\n\n/test-ns/djradon/picks/                          # data node (versioned dataset)\n├── _data-flow/                                       # node flow (data)\n│   ├── _current/                                # flow snapshot\n│   │   ├── djradon-picks.trig                    # current picks data\n│   │   ├── djradon-picks.jsonld\n│   │   └── index.html                           # resource page\n│   ├── _next/                                   # flow snapshot (draft)\n│   │   ├── djradon-picks.trig                    # draft picks data\n│   │   ├── djradon-picks.jsonld\n│   │   └── index.html                           # resource page\n│   ├── _v1/                                     # flow snapshot (version 1)\n│   │   ├── djradon-picks_v1.trig                 # version 1 snapshot\n│   │   └── index.html                           # resource page\n│   ├── _v2/                                     # flow snapshot (version 2)\n│   │   ├── djradon-picks_v2.trig                 # version 2 snapshot\n│   │   └── index.html                           # resource page\n│   └── index.html                               # resource page\n├── _meta-flow/                                       # node flow (metadata)\n│   ├── _current/                                # flow snapshot\n│   │   ├── djradon-picks_meta.trig              # versioning metadata, series info\n│   │   └── index.html                           # resource page\n│   ├── _next/                                   # flow snapshot (draft)\n│   │   ├── djradon-picks_meta.trig              # draft versioning metadata\n│   │   └── index.html                           # resource page\n│   └── index.html                               # resource page\n├── djradon-picks.trig                            # aggregated distribution\n├── index.html                                   # resource page\n└── CHANGELOG.md                                 # resource documentation\n\n/test-ns/djradon/underbrush/playlists/                              # bare node (container for playlist series)\n├── _meta-flow/                                       # node flow (metadata)\n│   ├── _current/                                # flow snapshot\n│   │   ├── playlists_meta.trig                  # metadata about playlist namespace\n│   │   └── index.html                           # resource page\n│   ├── _next/                                   # flow snapshot (draft)\n│   │   ├── playlists_meta.trig                  # draft metadata\n│   │   └── index.html                           # resource page\n│   └── index.html                               # resource page\n├── index.html                                   # resource page\n├── 1996-11-10/                                  # data node (individual playlist)\n│   ├── _data-flow/                                   # node flow (data)\n│   │   ├── _current/                            # flow snapshot\n│   │   │   ├── 1996-11-10.trig                   # playlist data\n│   │   │   └── index.html                       # resource page\n│   │   ├── _next/                               # flow snapshot (draft)\n│   │   │   ├── 1996-11-10.trig                   # draft playlist data\n│   │   │   └── index.html                       # resource page\n│   │   └── index.html                           # resource page\n│   ├── _meta-flow/                                   # node flow (metadata)\n│   │   ├── _current/                            # flow snapshot\n│   │   │   ├── 1996-11-10_meta.trig             # playlist metadata\n│   │   │   └── index.html                       # resource page\n│   │   ├── _next/                               # flow snapshot (draft)\n│   │   │   ├── 1996-11-10_meta.trig             # draft playlist metadata\n│   │   │   └── index.html                       # resource page\n│   │   └── index.html                           # resource page\n│   ├── _assets/                                 # asset tree\n│   │   ├── _meta-flow/                               # node flow (metadata)\n│   │   │   ├── _current/                        # flow snapshot\n│   │   │   │   ├── 1996-11-10_assets.trig       # asset metadata\n│   │   │   │   └── index.html                   # resource page\n│   │   │   ├── _next/                           # flow snapshot (draft)\n│   │   │   │   ├── 1996-11-10_assets.trig       # draft asset metadata\n│   │   │   │   └── index.html                   # resource page\n│   │   │   └── index.html                       # resource page\n│   │   ├── cover-photo.jpg\n│   │   └── index.html                           # resource page\n│   ├── 1996-11-10.trig                           # aggregated distribution\n│   └── index.html                               # resource page\n└── 1996-11-17/                                  # data node (another playlist)\n    ├── _data-flow/                                   # node flow (data)\n    │   ├── _current/                            # flow snapshot\n    │   │   ├── 1996-11-17.trig\n    │   │   └── index.html                       # resource page\n    │   ├── _next/                               # flow snapshot (draft)\n    │   │   ├── 1996-11-17.trig\n    │   │   └── index.html                       # resource page\n    │   └── index.html                           # resource page\n    ├── _meta-flow/                                   # node flow (metadata)\n    │   ├── _current/                            # flow snapshot\n    │   │   ├── 1996-11-17_meta.trig\n    │   │   └── index.html                       # resource page\n    │   ├── _next/                               # flow snapshot (draft)\n    │   │   ├── 1996-11-17_meta.trig\n    │   │   └── index.html                       # resource page\n    │   └── index.html                           # resource page\n    ├── 1996-11-17.trig                           # aggregated distribution\n    └── index.html                               # resource page\n\n```\n","n":0.035}}},{"i":102,"$":{"0":{"v":"Flow","n":1}}},{"i":103,"$":{"0":{"v":"static site generation","n":0.577},"1":{"v":"\n- theoretically every resource [[resource.node-component.documentation-resource.resource-page]] could look\n  different or even be generated by a different site generator\n- instead of generating to a docs folder or branch, the index files can just be\n  generated in-place!\n- commit to main = publish!\n\n## What Gets Included\n\n- the [[resource.node-component.documentation-resource.readme]] would probably be the primary source in practice\n- you could supplement AI-generated summaries\n\n## Issues\n\n## Resolved Issues\n\n- remove _x, we're doing publish-in-place","n":0.124}}},{"i":104,"$":{"0":{"v":"Working Distribution","n":0.707},"1":{"v":"\n\n\nUnlike most other [[resource.node-component.flow-snapshot]], the [[resource.node-component.flow-snapshot.next]] is [[user-facing|facet.user]] (directly modifiable), and so there shouldn't be any [[concept.sibling-distribution]]. Just the one distribution that may be updated, and if multiple-syntax weaving is turned-on, is the source for the siblings.\n\nThe [[product.cli]] should have functionality for converting the working distribution between formats, in case you want to change the syntax you're using.\n","n":0.131}}},{"i":105,"$":{"0":{"v":"Weave Process","n":0.707},"1":{"v":"\n- checks for required [[facet.system]] and creates them if missing\n- optionally removes extraneous files, interactively if requested\n- for changed [[facet.user]] datasets (i.e., need version bump)\n  - if versioning is on:\n    - creates a new [[resource.node-component.flow-snapshot.version]] \n    - updates version metadata\n  - regardless of whether versioning is on:\n    - copies _next to _current\n    - updates _meta-flow with new version information\n- regenerates affected [[resource.node-component.documentation-resource.resource-page]]\n\n```file\n/repo-root/\n├── _assets/\n│   ├── _templates/\n│   │   ├── default.html\n│   │   ├── ontology.html\n│   │   └── person.html\n│   └── _css\n│   │   ├── default.css\n│   │   ├── ontology.css\n│   │   └── person.css\n└── my-ontology/\n    ├── _config-flow              ← Node config (just syntax, etc.)\n    ├── _assets/                  ← Optional node-specific assets\n    │   ├── _templates/           ← Optional templates\n    │   └── _css                  ← Optional css\n    └── _data-flow\n```\n\n## Quirks\n\n- if there's a pre-existing index.html under _assets, don't overwrite it?\n  - or maybe use AI to update it.\n  - (might need some marker html to indicate index.html was generated by weave process)\n\n## Best Practices\n\n### Weave Before Push\n\nThis ensures that in published meshes and sites:\n\n- broken references are cleaned up\n- [[resource.node-component.flow-snapshot.current]] is identical to the latest version\n\n## Features\n\n### Verification\n\n- ensure that [[folder.node]] are only contained in other [[folder.node]].\n- detect [[principle.transposability]]\n\n### Interactive Mode\n\n- to encourage data quality, the weave process can include an interactive mode, or modes. Perhaps one mode is naive, like \"step through every bit of metadata\" or \"review every inferred metadata item\", but you could have an AI-driven mode that optimizes for importance, identifying possible errors based on usage, etc.\n\n### Tombstoning\n\nIf you know a sub-mesh is permanently moving to a new location (or even if a branch is being created somewhere else), you should be able to tell weave to insert references to the new location\n\n### Resource Page Generation\n\n- uses the [[product.service.design.in-memory]] to calculate template usage\n- if no templates specified, and no \"default template\" exists in the root, it can generate its own\n  - perhaps there's a default template and css distributed with the service in case its missing from the mesh root\n\n## Scope\n\n- **Single flow weave**: Update one (user) flow (data, ref, or config) + the corresponding meta-flow\n- **Node weave**: Update all (user) flows in a node (each flow + meta gets woven)\n- **Node tree weave**: Recursively weave nodes and their contained nodes\n\n**Meta-flow co-weaving**: whenever any flow in a node gets woven, the meta-flow updates to reflect the new state. This ensures the meta-flow always accurately describes the current node state without requiring separate meta-weaving operations.\n\nThis gives you:\n- **Local consistency**: Each node stays internally consistent\n- **Flexible granularity**: Can weave at flow, node, or tree level as needed\n- **Automatic meta updates**: No manual meta-flow management\n- **Simple model**: No complex cross-node locking or coordination\n\nFor contained nodes mentioned in config flows, any references ideally point to the appropriate version snapshot. If there's inconsistency during concurrent operations, it's temporary and resolves when operations complete (.7).\n\nThis seems like the right balance between consistency guarantees and implementation complexity for the mesh architecture. We can always add more sophisticated coordination later if specific use cases demand it.\n","n":0.045}}},{"i":106,"$":{"0":{"v":"Versioning","n":1},"1":{"v":"\nOnly [[resource.node-component.flow]] may be versioned. But that effectively means everything important can be versioned. \n\nVersioning is controlled in the [[resource.node-component.node-config-defaults]].","n":0.224}}},{"i":107,"$":{"0":{"v":"Concept Summary","n":0.707},"1":{"v":"\n# Semantic Mesh — LLM-Oriented Concept Summary\n\nThis document is the canonical, compact context for AIs/LLMs. It summarizes all `documentation/concepts.*` notes and cross-links to authoritative pages.\n\n0) Twin Purposes\n- Mint URLs (IRIs) for referring to things on the Semantic Web.\n- Hold semantic datasets and supporting resources that use those URLs.\n\n1) Definition\nA semantic mesh is a dereferenceable, folder-structured, possibly-versioned corpus of semantic resources where every URL resolves to meaningful content. A mesh maps directly from a Git repository’s folder hierarchy to a published static site so that:\n- Every resource is addressable by a stable URL.\n- Folder resources are dereferenceable via generated `index.html` resource pages.\n- RDF datasets live as distributions on versioned flow snapshots.\n- The weave process maintains coherence and keeps the repo publish-ready.\n\nSee:\n- [[concept.mesh]]: definition, requirements\n- [[concept.semantic-site]]: site posture\n- [[concept.mesh-repo]]: repo-to-site mapping\n\n2) Design Principles\n- [[principle.dereferencability-for-humans]]: resource pages\n- [[principle.single-referent]]: concept vs content is explicit\n- [[principle.pseudo-immutability]]: treat version snapshots/IDs as immutable\n- [[principle.transposability]]: move meshes without breaking links via relative IDs\n- [[principle.composability]]: extract/compose submeshes\n\n3) Core Abstractions\n\n3.1 Mesh Resources (Nodes and Components)\n- Node (folder; container for nodes & components): [[concept.mesh.resource.node]]\n  - bare node: organizational URL segment container: [[concept.mesh.resource.node.namespace]]\n  - data node: URL refers to the node’s referent (real-world entity or dataset concept); has a data flow: [[concept.mesh.resource.node.data]]\n  - Dataset-series specialization (optional): [[concept.mesh.resource.node.data.series]]\n\n- Node component (terminal resource supporting a node): [[resource.node-component]]\n  - Flows (abstract datasets as DatasetSeries):\n    - Meta flow (metadata/provenance): [[resource.node-component.flow.node-metadata]]\n    - Data flow (payload data): [[resource.node-component.flow.data]]\n    - Node-config flows (settings; see §9): [[resource.node-component.flow.node-config]]\n  - Flow snapshots (concrete Datasets): `_current/`, `_next/`, `_vN/`\n    - Overview: [[resource.node-component.flow-snapshot]]\n    - `_current/`: [[resource.node-component.flow-snapshot.current]]\n    - `_next/`: [[resource.node-component.flow-snapshot.next]]\n    - `_vN/`: [[resource.node-component.flow-snapshot.version]]\n    - Distributions: [[resource.node-component.flow-snapshot.distribution]]\n  - Handle (refer to the node “as a mesh resource”): [[resource.node-component.node-handle]]\n    - Handle page (human-facing): [[resource.node-component.handle.page]]\n  - Asset tree (static files for the node): [[resource.node-component.asset-tree]]\n  - Documentation resources (README/CHANGELOG/resource pages/fragments):\n    - README: [[resource.node-component.documentation-resource.readme]]\n    - CHANGELOG: [[resource.node-component.documentation-resource.changelog]]\n    - Resource page (index.html): [[resource.node-component.documentation-resource.resource-page]]\n    - Resource fragment: [[resource.node-component.documentation-resource.resource-fragment]]\n  - Aggregated distribution (optional roll-up of child node data): [[resource.node-component.aggregated-distribution]]\n\n3.2 Facets (Folder, File, Dataset)\n- Folder facet (namespace mapping; reserved folders): [[concept.mesh.resource-facet.folder]]\n- File facet (content retrieval): [[concept.mesh.resource-facet.file]]\n- Dataset facet (DatasetSeries vs Dataset): [[concept.mesh.resource-facet.dataset]]\n\n4) Addressing and Identity\n\n4.1 Namespace and Relative Identifiers\n- Folder names become namespace segments; the path is the node’s relative identifier (and URL path when published).\n- Relative identifiers are used within distributions for transposability; resolve relative to distribution location.\nSee:\n- [[concept.namespace]]: overview\n- [[concept.namespace.segment]]: segment definition\n- [[concept.namespace.segment.system]]: reserved segments\n- [[concept.identifier.intramesh]]: relative IDs\n\n4.2 URL Semantics\n- Concept URLs (slash-terminated) identify nodes, flows (abstract), snapshots (conceptual), and handle.\n- Content URLs (with filenames) identify retrievable files: distributions, HTML pages, READMEs, assets.\n- Follow document-vs-thing hygiene to avoid ambiguity.\nSee:\n- [[concept.identifier]]: URL types and mapping\n- [[faq.reference-iri-choices]]: trade-offs\n- [[concept.iri]]: terminology; prefer “URLs” when referring to mesh-local IRIs\n\n4.3 Handle Rationale\n- A node’s URL refers to its referent (namespace, real-world entity, or dataset concept).\n- The handle component provides a URL to refer to the node itself “as a mesh resource” (for config, provenance, lifecycle).\nSee:\n- [[resource.node-component.node-handle]]\n- [[resource.node-component.handle.page]]\n\n5) Physical Structure and Reserved Folders\n\nReserved folder names (underscore-prefixed; canonical set):\n- `_node-handle/`\n- Flow containers (abstract datasets):\n  - `_meta-flow/`, `_data-flow/`\n  - `_config-operational-flow/`, `_config-inheritable-flow/` (see §9)\n- Snapshots inside a flow:\n  - `_current/`, `_next/`, `_vN/` (e.g., `_v1/`, `_v2/`, …)\n- Assets:\n  - `_assets/` (static files)\n\nFolder-note pages for these reserved names live under `concept.mesh.resource.folder.*.md` (where defined):\n- `_meta-flow/`: [[concept.mesh.resource.folder._meta-flow]]\n- `_data-flow/`: [[concept.mesh.resource.folder._data-flow]]\n- `_config-operational-flow/`: [[concept.mesh.resource.folder._config-operational-flow]]\n- `_config-inheritable-flow/`: [[concept.mesh.resource.folder._config-inheritable-flow]]\n- `_current/`: [[concept.mesh.resource.folder._current]]\n- `_next/`: [[concept.mesh.resource.folder._next]]\n- `_vN/`: [[concept.mesh.resource.folder._vN]]\n- `_assets/`: [[concept.mesh.resource.folder._assets]]\n- Node folder pages:\n  - Node: [[concept.mesh.resource.folder.node]]\n  - Namespace: [[concept.mesh.resource.folder.namespace]]\n\n6) Data and Versioning Model\n- Only flows are versioned (flows are DatasetSeries). Nodes are not versioned.\n- Flow snapshots:\n  - `_current/`: latest stable realization; after weave it equals the content of the latest `_vN/`.\n  - `_next/`: mutable working area.\n  - `_vN/`: immutable history for precise citation and provenance.\n- Working distribution: `_next/` typically contains a single editable source; weave can fan-out serializations.\n- Sibling distribution: patterns and constraints for multi-file realizations.\nSee:\n- [[concept.versioning]]\n- [[concept.working-distribution]]\n- [[concept.sibling-distribution]]\n\n7) Lifecycle and Weave Process\nWeave maintains structural coherence and publication readiness:\n- Ensures required system components exist.\n- If versioning is enabled, creates a new `_vN/` from `_next/`.\n- Promotes `_next/` contents to `_current/`.\n- Updates meta/provenance; regenerates resource pages.\n- Resolves internal links to maintain transposability.\n- Integrates with the scanner where applicable.\nSee:\n- [[concept.weave-process]]\n- [[concept.flow.page-generation]]\n- [[concept.scanner]]\n- [[concept.metadata.provenance]]\n\n8) Publishing and Sites\n- Repos are static-site-ready; pushing to GitHub Pages or any static host publishes the mesh (folder paths → URL paths).\n- Transposition (domain/project move) is safe with relative IDs.\nSee:\n- [[concept.mesh-repo]]\n- [[concept.semantic-site]]\n- [[concept.publication]]\n\n1) Configuration and Inheritance (Two Config Flows)\n- Operational Config Flow: final, resolved settings for a node (consumer). Overrides apply here.\n- Inheritable Config Flow: settings a node offers to descendants (provider). Property-level merge; order: parent → … → service → platform; propagation can be firewalled.\n- Resolution: a single inheritance mechanism resolves operational config from inheritable configs plus service/platform defaults. Explicit operational entries override inherited ones.\nSee:\n- [[resource.node-component.flow.node-config]]: overview\n- [[resource.node-component.flow.node-config.operational]]\n- [[resource.node-component.flow.node-config.inheritable]]\n- [[resource.node-component.node-config-defaults]]: defaults as inheritable values\n\n1)  Aggregated Views\n- Aggregated distribution: optional roll-up of child data nodes’ current datasets at a parent node for convenience.\nSee:\n- [[resource.node-component.aggregated-distribution]]\n\n1)  Minimal File Tree Example\n\n```\n/repo-root/\n├── _assets/                         # optional site-wide assets\n├── my-node/                         # a mesh node (folder)\n│   ├── _node-handle/                # handle component (resource.node-component.node-handle)\n│   ├── _meta-flow/                  # metadata flow (system)\n│   │   ├── _current/\n│   │   └── _v1/\n│   ├── _data-flow/                  # data flow (for data nodes)\n│   │   ├── _current/\n│   │   ├── _next/\n│   │   └── _v1/\n│   ├── _config-inheritable-flow/    # provider config (optional)\n│   ├── _config-operational-flow/    # resolved config (optional; may be system-written)\n│   ├── index.html                   # resource page\n│   ├── README.md\n│   └── CHANGELOG.md\n└── docs/ or public host mapping     # publication target\n```\n\n12) Visual Overview\n\n```mermaid\ngraph TD\n  A[Mesh Node] --> B[Handle]\n  A --> C[Meta flow]\n  A --> E[Data flow]\n  A --> G[Asset tree]\n  A --> H[Resource pages]\n\n  C --> C1[_current]\n  C --> C2[_vN]\n  E --> E1[_current]\n  E --> E2[_next]\n  E --> E3[_vN]\n```\n\n13) Glossary\n- [[concept.mesh]]: the set of addressable resources in a repository, published as a site\n- Node: an extensible folder resource containing nodes/components: [[resource.node]]\n- Node component: terminal resource that supports node behavior/structure: [[resource.node-component]]\n- Flow: DatasetSeries representing an abstract dataset (meta/data/config): [[resource.node-component.flow]]\n- [[resource.node-component.flow-snapshot]]: concrete Dataset realization of a flow (`_current/`, `_next/`, `_vN/`)\n- [[resource.node-component.snapshot-distribution]]: a concrete serialization file (TriG, JSON-LD, etc.): \n- Handle: indirection to refer to the node “as a mesh resource”: [[resource.node-component.node-handle]]\n- Resource Page: dereferenceable `index.html` for folders: [[resource.node-component.documentation-resource.resource-page]]\n- Aggregated Distribution: parent-level roll-up of children’s current data: [[resource.node-component.aggregated-distribution]]\n- Weave: lifecycle operation to version/promote/regenerate/repair: [[concept.weave-process]]\n- Evidence:\n  - TriG appears unsupported while docs/examples use TriG heavily: [[resource.node-component.flow-snapshot.distribution]]\n- Recommendation: Make TriG and JSON-LD first-class supported formats; document status for TTL, N-Quads, RDF/XML.\n\nK. Config defaults doc should include explicit property names/shapes\n- Evidence:\n  - [[resource.node-component.node-config-defaults]] lacks concrete JSON-LD terms/examples\n- Recommendation: Provide explicit terms/shapes aligned with config-flow vocabulary and the inheritance resolution doc.\n\nL. Relative identifier examples mention `_config-flow`\n- Evidence:\n  - [[concept.identifier.intramesh]] vs config docs (two config flows): [[resource.node-component.flow.node-config]]\n- Recommendation: Align examples with `_config-operational-flow/` and `_config-inheritable-flow/`.\n\nM. Confirm embedded mesh doc and folder-note coverage\n- Evidence:\n  - [[concept.mesh.embedded]] exists; ensure it’s linked where appropriate (namespace/base docs).\n- Recommendation: Link embedded mesh doc from base/namespace docs.\n\n1)  Minimal “Core Context” to feed an LLM\nIf context must be small, include:\n- Definition (§1) and Principles (§2).\n- Node vs Component; Flows vs Snapshots (§3).\n- URL semantics and relative identifiers (§4).\n- Reserved folders and example tree (§5, §11).\n- Lifecycle and weave (§7).\n- Config flows model (§9).\n- Aggregated views (§10).\n\n1)  LLM Usage Notes\n- Use the folder names and URL semantics exactly as standardized here.\n- When encountering contradictions, prefer the standards in §14 recommendations.\n- When linking within the mesh, prefer relative identifiers to maintain transposability.\n- Avoid “IRI/URI” unless drawing a distinction; for mesh-local identifiers, use “URLs”.\n","n":0.029}}},{"i":108,"$":{"0":{"v":"Sibling Distribution","n":0.707},"1":{"v":"\n- same data, different syntax","n":0.447}}},{"i":109,"$":{"0":{"v":"Semantic Site","n":0.707},"1":{"v":"\nSemantic Flow sites provide two main services:\n\n- hosting persistent, namespaced [[URLs|concept.identifier]] for use in the semantic web\n- hosting versioned RDF datasets, and their histories\n\n## Publishing\n\n- For sites exposed by Github/Gitlab Pages functionality, pushing a [[concept.mesh-repo]] effectively publishes it.\n","n":0.162}}},{"i":110,"$":{"0":{"v":"Scanner","n":1},"1":{"v":"\n- scans datasets and dataset distributions, which can be :\n  - local folders\n  - git repos\n  - compliant URLs\n  - SPARQL data sources\n- can filter which subfolders to include/exclude\n- ","n":0.186}}},{"i":111,"$":{"0":{"v":"root node","n":0.707},"1":{"v":"\nThe node at the top of a repository file hierarchy may be referred to as the root node. It is the [[concept.namespace.base]], even if it is not a [[resource.node.bare]]. \n\nEvery other [[resource]] in a mesh \"lives under\" the root folder, and its identifier is the folder name, which is usually the repo-name if it's being created as a [[concept.mesh-repo]]. \n\nIt is not treated or represented any differently than any other [[resource.node]], and it is not differentiated in metadata (hopefully?)","n":0.113}}},{"i":112,"$":{"0":{"v":"Referent","n":1},"1":{"v":"Perfect — here’s an extended wiki note that folds in that case:\n\n---\n\n## Referent\n\n**Definition**\nThe *referent* is the thing (real or imaginary) that a node’s IRI **refers to**. Every node IRI is an identifier for its referent.\n\n**Node vs. referent**\n\n* **Referent**: the subject that the node’s IRI names (a person, concept, event, dataset, etc.).\n* **Node**: the mesh construct that manages flows about that referent.\n\n  * To talk about the node itself, you use its **node handle** (e.g. published IRI `https://ns.example.org/persons/djradon/_node-handle` or mesh identifier `<djradon/_node-handle>`).\n\n**Where it’s described**\n\n* The **referent’s description** lives in the node’s [[resource.node-component.flow.reference]].\n* The **node’s own metadata and provenance** live in the **`_node-*` flows** (e.g. `_node-metadata-flow`, `_node-config-*`).\n\n**Special case: data nodes**\n\n* In a **data node**, the **referent** is not an external entity but an **evolvable dataset** contained in the node.\n* The dataset evolves as versioned distributions inside the node’s `_data-flow` (e.g. `v1/`, `v2/`, …).\n* The `_ref-flow` may describe the dataset, e.g. its **name, type, and provenance**.\n* Example:\n\n  * Node IRI: `https://ns.example.org/projects/atlas/`\n  * Referent: *the Atlas dataset* (identified by the node IRI, evolving over time).\n  * `_ref-flow`: declares it as a dataset, supplies label and attribution.\n  * `_data-flow`: provides concrete versions (`v1`, `v2`, …).\n\n---\n\n👉 Would you like me to also draft the **paired wiki note for “Node handle”**, so your docs have “Referent” and “Node handle” defined side-by-side?\n","n":0.068}}},{"i":113,"$":{"0":{"v":"Publication","n":1},"1":{"v":"\n\n## Publication History Tracking\n\nThe inferred publication locations can be used to maintain a history of where a mesh has been published, which aids in citation consistency and discovery:\n\n```turtle\n# In _flow/ metadata\n<_node-handle> sf:publishedAt <https://myorganization.github.io/data-mesh/ns/djradon/> ;\n          sf:previousPublications ( \n            <https://djradon.github.io/mesh/ns/djradon/>\n            <https://oldsite.com/research/ns/djradon/>\n          ) ;\n          sf:gitRemote <https://github.com/myorganization/data-mesh.git> ;\n          sf:movedFrom <https://github.com/djradon/mesh.git> .\n```\n\nThis allows external citations to find resources even after they've been moved, and provides a clear provenance trail.\n","n":0.125}}},{"i":114,"$":{"0":{"v":"platform element","n":0.707},"1":{"v":"\nA **platform element** is a aspect of the Semantic Flow platform, including\n  - conceptual elements \n  - filesystem elements, facets, ontologies, and conventions. \n","n":0.204}}},{"i":115,"$":{"0":{"v":"node config","n":0.707},"1":{"v":"\n## per-node config specification\n\nNode configuration determines:\n\n- flow versioning\n- resource page and resource fragment generation\n- distribution syntaxes\n- template usage and stylesheets\n- attribution defaults\n\nNode configuration is held in memory by the [[flow service|sflo.product.service]], and is calculated when the service starts.\n\nNode configuration is at least partially determined by \"config specification\", which happens in [[resource.node-component.flow.node-config]] and can be inherited to contained nodes.\n\nIf config specification is missing, (i.e., config spec inheritance is turned off or unspecified), node configuration will be determined from service-level config specification, i.e. [[product.service.config]]. In case there is none, the service will use sensible defaults at the root level which will be inherited down the mesh.\n\n### Initial Config Specification\n\n- When a node is initially created, if config-defaults-inheritance is turned on for its parent node, it will have its [[resource.node-component.flow.node-config]] populated based on any parent [[resource.node-component.node-config-defaults]] files present in the hierarchy. If there are none, its [[resource.node-component.flow-snapshot.current]] will not be created.\n\n### Calculating Node Config\n\nWhen the [[product.sflo-host]] starts, it calculates non-default config settings for every node.\n\n- determines the \"default\" settings for this service instance from [[product.service.config]]\n- if the node has a [[resource.node-component.flow.node-config]] , the service will use any settings there that differ from its defaults\n- if config-inheritance is turned on for a node, the service will scan back up the hierarchy to compose any missing \"non-default\" settings\n-  the result is an in-memory \"shadow mesh\" known as the [[product.service.components.node-config-map]] containing any non-default settings for the mesh\n\nIf calculated config matches the service defaults, they are ignored.\n\n## per-service settings for node defaults\n\n- [[product.service.config]] can establish any mesh-wide settings that diverge from the system defaults\n\n## platform node-config defaults\n\nSemantic Flow uses sensible defaults, specified in the so that neither node-level nor service-level \"non-default\" settings are necessary\n\n- by default:\n  - versioning is turned on for all flows\n  - distribution syntaxes are .trig and jsonld\n  - resource pages are generated using a standard template and CSS file that get copied into a [[concept.mesh-repo]]'s root [[resource.node-component.asset-tree]] upon initialization\n  - [[resource.node-component.aggregated-distribution]] are not generated\n  - [[concept.mesh.resource.element.flow.unified]]\n","n":0.056}}},{"i":116,"$":{"0":{"v":"Namespace","n":1},"1":{"v":"\n## Overview\n\nA namespace is the hierarchical address space formed by folder names (segments). Every folder extends the namespace with its name, and the resulting path maps directly to the published URL.\n\n- Concept vs content URL semantics: see [[concept.identifier]]\n- How intramesh identifiers are resolved: see [[concept.identifier.intramesh]]\n\n## Node Types\n\nA [[bare node|resource.node.bare]] is a mesh node whose URL refers to the namespace itself (an organizational container). The other node type is:\n\n- [[data node|resource.node.reference.dataset]]: URL refers to the node’s referent (real-world entity or dataset concept) and has a single [[data flow|resource.node-component.flow.data]].\n\nFor general node anatomy (handle and metadata requirements), see [[resource.node]].\n\n## Minimal Example\n\n```file\n/ns/                         # bare node → https://ex.org/ns/\n└── people/                  # bare node → https://ex.org/ns/people/\n    └── alice/              # data node → https://ex.org/ns/people/alice/\n```\n\n- Folder names become namespace segments.\n- Slash-terminated URLs identify concepts; file URLs identify content (see [[concept.identifier]]).\n\n## Publishing Base\n\nThe site’s base URL is determined by the publishing platform (e.g., GitHub Pages or self-hosting with [[product.sflo-host]]). See [[concept.namespace.base]] for user/org vs project page mappings and guidance on avoiding hardcoded bases.\n","n":0.078}}},{"i":117,"$":{"0":{"v":"Namespace Segment","n":0.707},"1":{"v":"\n## Definition\n\nA namespace segment is a single folder name that extends the namespace (URL) path. The concatenation of folder names yields the full namespace path for a node.\n\n- Concept vs content URL semantics: see [[concept.identifier]]\n- How relative identifiers are resolved: see [[concept.identifier.intramesh]]\n\n## Naming (recommended)\n\n- Use kebab-case (lowercase letters, digits, hyphens), e.g., `people`, `my-projects`\n- Avoid spaces and uppercase to reduce churn in URLs\n- Maybe avoid starting segment names names with an underscore (`_`); underscore-prefixed names are used for [[concept.namespace.segment.system]]\n\nThese are recommendations, not hard rules; sometimes projects have good reasons to diverge.\n\n## Stability\n\nRenaming a segment probably breaks the identifier (URL) of all contained resources. If you must rename:\n\n- Consider redirect/tombstoning strategies and publication history — see [[concept.publication]]\n- Review impacts on inbound references; plan a weave and re-publish cycle\n- see also [[feature.handling-renaming]]\n\n## Example\n\n```file\n/ns/                         → https://ex.org/ns/\n└── datasets/                → https://ex.org/ns/datasets/\n    └── census/              → https://ex.org/ns/datasets/census/\n```\n\n- Each folder adds exactly one namespace segment\n- Folders map directly to slash-terminated concept URLs (see [[concept.identifier]])\n","n":0.08}}},{"i":118,"$":{"0":{"v":"system segments","n":0.707},"1":{"v":"\nSystem segments are underscore-prefixed folder names reserved by the platform. Prefer not to use `_`-prefixed names for user-defined segments.\n\nThis page is the canonical list; see the linked docs for behavior and details.\n\n## Flows (abstract/series)\n\n- [[_meta-flow/|folder._node-metadata-flow]]\n- [[_data-flow/|folder._data-flow]]\n- [[_config-operational-flow/|folder._config-operational-flow]]\n- [[_config-inheritable-flow/|folder._config-inheritable-flow]]\n\n## Snapshots (concrete)\n\n- [[_current/|folder._current]]\n- [[_next/|folder._next]]\n- [[_vN/|folder._vN]]\n\n## Other reserved\n\n- [[_node-handle/|folder._node-handle]]\n- [[_assets/|folder._assets]]\n\nFor URL semantics: see [[concept.identifier]]. For namespace background: see [[concept.namespace]] and [[concept.namespace.segment]].\n","n":0.131}}},{"i":119,"$":{"0":{"v":"namespace base","n":0.707},"1":{"v":"\n## Overview\n\nThe namespace base is the URL prefix under which a [[concept.semantic-site]] publishes all mesh identifiers. It is outside the mesh’s folder tree and is determined by the hosting platform.\n\n- Concept vs content URL semantics: see [[concept.identifier]]\n- Transposability guidance (avoid hardcoded bases): see [[principle.transposability]]\n- Publication history patterns: see [[concept.publication]]\n\nOnly sites have a namespace base. Meshes (and sites) also have a [[concept.root-node]], which corresponds to the top-level folder of the mesh.\n\n## Platform mappings (GitHub Pages examples)\n\n- User/Org site base:\n  - `https://org.github.io/`\n  - Mesh path `/ns/people/alice/` publishes at `https://org.github.io/ns/people/alice/`\n- Project site base with a [[concept.mesh-repo]]:\n  - `https://org.github.io/repo/`\n  - Mesh path `/ns/people/alice/` publishes at `https://org.github.io/repo/ns/people/alice/`\n- Project site base with an [[concept.mesh.embedded]]\n\n## Guidance\n\n- Prefer relative or site-root-absolute paths inside the mesh; do not hardcode full base IRIs so the mesh remains portable across hosting locations (see [[faq.reference-iri-choices]]).\n- The base is a deployment concern; the mesh folder tree should be valid regardless of where it is served.\n","n":0.081}}},{"i":120,"$":{"0":{"v":"Namespace Relative Basing","n":0.577},"1":{"v":"\nPerfect — I like **intramesh identifiers** as a project-specific term, since it makes clear: “these are inside the mesh, and they behave like relative IRIs but with conventions.” 👍\n\nHere’s a doc-style write-up on **namespace-relative basing**, phrased to integrate with your terminology and conventions:\n\n---\n\n# Namespace-Relative Basing\n\nIn Semantic Flow, distributions are often nested deeply inside a node’s flows (e.g., `_data-flow/_current/...`). If base IRIs are left implicit, relative identifiers would need multiple `../` steps to reach the node or its siblings. To simplify this, Semantic Flow recommends **namespace-relative basing**.\n\n## Concept\n\n* Every distribution file declares an explicit `@base` (in TriG/Turtle) or `@context/@base` (in JSON-LD).\n* Instead of using the document’s path as the base (the default in RDF), the base is set **relative to the namespace root** (one level above the node root).\n* This makes the **namespace root** the anchor, so that nodes can be referred to by simple `<name>` identifiers.\n\n### Path layout\n\n```\nnamespace-root/\n  djradon/\n    _data-flow/_current/djradon.trig\n    _meta-flow/_current/meta.trig\n  another-node/\n```\n\n### With namespace-relative basing\n\n```turtle\n@base <../../../> .\n\n<djradon> a :Node ;\n  :hasMeta <djradon/_meta-flow/_current/meta.trig> ;\n  :relatedTo <another-node> .\n```\n\n* `<>` resolves to the namespace root (`namespace-root/`).\n* `<djradon>` resolves to the node (`namespace-root/djradon/`).\n* `<another-node>` is a sibling in the namespace.\n* Intra-node flows are reached with `djradon/...`.\n\n---\n\n## Advantages\n\n* **Sibling references are short**: `<another-node>` instead of climbing out with `../../../`.\n* **Node references are stable**: `<djradon>` always means the node root, regardless of where the distribution lives.\n* **Clarity**: `<>` = namespace, `<name>` = node, `<name/path>` = subresources.\n\n---\n\n## Comparison with Node-Relative Basing\n\n| Basing Style           | `@base` value | `<>` =         | `<djradon>` = | Best For…                                    |\n| ---------------------- | ------------- | -------------- | ------------- | -------------------------------------------- |\n| **Node-relative**      | `../../`      | Node root      | Child of node | Config/meta flows describing the node itself |\n| **Namespace-relative** | `../../../`   | Namespace root | Node root     | Data/reference flows linking across nodes    |\n\n---\n\n## Guidelines\n\n* ***data-flow* and *ref-flow*** distributions should use **namespace-relative basing**, since they often refer to siblings or other nodes.\n* ***meta-flow* and *config-flow*** distributions may use **node-relative basing** if they mostly describe the node itself.\n* Always set `@base` explicitly in every distribution to avoid fragile relative paths.\n\n---\n\n## JSON-LD Example\n\n```json\n{\n  \"@context\": {\n    \"@base\": \"../../../\"\n  },\n  \"@id\": \"djradon\",\n  \"@type\": \"Node\",\n  \"hasMeta\": \"djradon/_meta-flow/_current/meta.trig\",\n  \"relatedTo\": \"another-node\"\n}\n```\n\n---\n\n✅ With namespace-relative basing, intramesh identifiers remain short, predictable, and consistent across all distributions, while still resolving correctly to absolute IRIs.\n\n","n":0.052}}},{"i":121,"$":{"0":{"v":"Metadata","n":1},"1":{"v":"\nAside from the metadata involved in datasets themselves, semantic meshes have operational metadata that capture things like:\n\n  [[concept.metadata.provenance]] (entities, agents, activities)\n- Copyright and licensing\n- validation / consistency checks\n- metrics","n":0.186}}},{"i":122,"$":{"0":{"v":"Provenance","n":1},"1":{"v":"\n## Core Principles\n\n**Version-only provenance** - Provenance is recorded only for immutable version snapshots (like `_v47`), not for moving targets like `_current` or `_next`.\n\n**Meta-flow storage** - Semantic Flow-specific provenance lives in meta-flows, referencing version snapshots in other flows. Domain-specific provenance can live in datasets themselves.\n\n**Current snapshot duplication** - `_current` meta snapshots contain identical copies of the latest version's provenance with base URI pointing to the version snapshot for stable fragment resolution.\n\n## Architecture\n\n### Version Snapshot Provenance\n\n```turtle\n# In my-dataset/_meta-flow/_v47/my-dataset_meta.trig\n@base <../_v47/> .\n\n# Weave activity with PROV standard properties\n:configUpdateActivity a meta:ConfigWeave ;\n    prov:startedAtTime \"2025-07-20T14:30:00Z\" ;\n    prov:endedAtTime \"2025-07-20T14:30:15Z\" ;\n    prov:used <../../_config-flow/_v46/config.jsonld> ;\n    prov:generated <../../_config-flow/_v47/config.jsonld> ;\n    prov:wasAssociatedWith <https://semantic-flow.org/agents/flow-service-bot> .\n\n# Rights and licensing at snapshot level\n<../../_config-flow/_v47> dcterms:rightsHolder <https://orcid.org/0000-0002-1825-0097> ;\n                          dcterms:license <https://creativecommons.org/licenses/by-sa/4.0/> ;\n                          prov:has_provenance :configProvenance .\n\n# Delegation chain (step 1 = top authority, gets copyright by default)\n:configProvenance a meta:ProvenanceContext ;\n    meta:forActivity :configUpdateActivity ;\n    meta:forSnapshot <../../_config-flow/_v47> ;\n    prov:wasAttributedTo <https://acme-corp.com/org> ; # Primary attribution\n    meta:delegationChain :delegationChain_001 .\n\n:delegationChain_001 meta:hasStep :step1, :step2, :step3 .\n\n:step1 a meta:DelegationStep ;\n       meta:stepOrder 1 ;\n       prov:agent <https://acme-corp.com/org> . # Prime mover, no actedOnBehalfOf\n\n:step2 a meta:DelegationStep ;\n       meta:stepOrder 2 ;\n       prov:agent <https://orcid.org/0000-0002-1825-0097> ;\n       prov:actedOnBehalfOf <https://acme-corp.com/org> .\n\n:step3 a meta:DelegationStep ;\n       meta:stepOrder 3 ;\n       prov:agent <https://semantic-flow.org/agents/flow-service-bot> ;\n       prov:actedOnBehalfOf <https://orcid.org/0000-0002-1825-0097> .\n```\n\n### Current Snapshot Copy\n\n```turtle\n# In my-dataset/_meta-flow/_current/my-dataset_meta.trig\n@base <../_v47/> .\n\n# Identical content to version snapshot - all URIs resolve to stable version\n# (same provenance content as above)\n```\n\n### Unversioned Flow Accumulation\n\nFor flows without versioning, activities accumulate in `_next` with unique timestamps:\n\n```turtle\n# In my-dataset/_meta-flow/_next/my-dataset_meta.trig\n:dataActivity_2025-07-20_14-30 a meta:DataWeave ;\n    prov:startedAtTime \"2025-07-20T14:30:00Z\" ;\n    prov:generated <../../_data-flow/_current/data.trig> .\n\n:dataActivity_2025-07-20_16-45 a meta:DataWeave ;\n    prov:startedAtTime \"2025-07-20T16:45:00Z\" ;\n    prov:used <../../_data-flow/_current/data.trig> ;\n    prov:generated <../../_data-flow/_current/data.trig> .\n```\n\n## Key Components\n\n### Activity Types (subclass `prov:Activity`)\n- `meta:ConfigWeave`, `meta:ReferenceWeave`, `meta:DataWeave`, `meta:MetaWeave`\n- `meta:NodeWeave` (entire node), `meta:NodeTreeWeave` (recursive)\n\n### Provenance Entities (subclass `meta:ProvenanceEntity`)\n- `meta:ProvenanceContext` - Relator for complex authorship scenarios\n- `meta:DelegationChain` / `meta:DelegationStep` - Authorization chains\n- `meta:AgentRoleCollection` / `meta:AgentRole` - Collaborative role assignments\n\n### Standard Properties Used\n- `prov:agent`, `prov:actedOnBehalfOf`, `prov:wasAttributedTo` (instead of custom properties)\n- `dcterms:rightsHolder`, `dcterms:license` (rights at snapshot level)\n- `prov:has_provenance` (link snapshots to provenance contexts)\n\n## Delegation Chain Pattern\n\n**Step ordering**: Lower numbers = higher authority\n- Step 1: Prime mover (organization) - gets copyright by default, no `prov:actedOnBehalfOf`\n- Step 2+: Each agent acts on behalf of the previous step's agent\n- Tools/software agents typically at the end of the chain\n\n## Configuration\n\n**Copyright assignment**: Configurable in node-config-defaults, defaults to first agent in delegation chain (step 1).\n\n**External vocabulary tracking**: Use SHACL to declare recommended external properties like `prov:wasInfluencedBy`, `dcterms:license`.\n\n## Implementation Notes\n\n- **Fragment URIs**: Use `<#step1>` etc. within version snapshots for stable addressability\n- **Base URI**: All snapshots use `@base <../_vN/>` pattern for consistent resolution\n- **Rights inheritance**: Capture previous version rights holders in provenance contexts when content is derived\n- **Static site friendly**: Documentation approach for external references since no server-side redirects available\n\n## Fragment Identifier Naming Scheme\n\nTo ensure that every RDF node within a `_meta` distribution has a unique and dereferenceable URI, the following naming scheme for fragment identifiers MUST be used. This allows the `index.html` file for a given snapshot version to correctly link to all provenance entities.\n\nThe structure is as follows:\n\n`<{flow-slug}-{version}-{entity-type}[-{unique-part}]>`\n\n-   **`{flow-slug}`**: The slug of the flow this provenance describes (e.g., `config-flow`, `data-flow`). This provides the primary namespace for the identifier.\n-   **`{version}`**: The version of the snapshot (e.g., `v47`). This scopes the provenance to a specific point in time.\n-   **`{entity-type}`**: The type of the entity, using a consistent camelCase or kebab-case convention (e.g., `activity`, `context`, `delegationChain`, `delegationStep`).\n-   **`{unique-part}`**: (Optional) A unique suffix, such as a step number or a timestamp, used when multiple entities of the same type exist for the same flow and version.\n\n### Example\n\nFor a `config-flow` at version `v47`, the identifiers would be:\n\n-   **Activity**: `<#config-flow-v47-activity>`\n-   **Provenance Context**: `<#config-flow-v47-context>`\n-   **Delegation Chain**: `<#config-flow-v47-delegationChain>`\n-   **Delegation Steps**:\n    -   `<#config-flow-v47-delegationStep-1>`\n    -   `<#config-flow-v47-delegationStep-2>`","n":0.041}}},{"i":123,"$":{"0":{"v":"semantic mesh","n":0.707},"1":{"v":"\n## Overview\n\nA **semantic mesh** is a dereferenceable, possibly-versioned, [[concept.immutability]] collection of semantic data and other resources where every HTTP URL returns meaningful content. It serves as the foundational structure for organizing and publishing semantic web resources through [[semantic sites|concept.semantic-site]].\n\nKey characteristics:\n- **Addressable**: Every [[resource]] has a unique [[concept.identifier.intramesh]]; when a mesh is [[published|concept.publication]], every  [[resource]] then gets a globally unique URL\n- **Dereferenceable**: All URLs return meaningful content when accessed\n- **Versioned**: Changes are managed through the [[Weave Process|concept.weave-process]] process, and [[resource.node-component.flow]] are versioned by default\n- **Publish-ready**: Can be served directly via GitHub Pages or similar static hosting; or via a local web server like live-server\n\n## Core Concepts\n\n### Mesh Resources\n\nThere are two types of mesh resources: [[resource.node]]s and [[resource.node-component]]s.\n\n#### Mesh Nodes\n\n[[Mesh nodes|resource.node]] are the primary structural components of a mesh, physically represented as [[mesh folders|facet.filesystem.folder]]. They extend namespaces and serve as containers.\n\n- **[[bare nodes|resource.node.bare]]**: Empty containers for organizing other mesh nodes\n- **[[data nodes|resource.node.reference.dataset]]**: Nodes containing data distributions with optional versioning\n\n\n#### Node components\n\n[[Node components|resource.node-component]] help define, support, and systematize nodes:\n\n## Folder-based\n\n- **[[resource.node-component.flow]]** and their [[resource.node-component.flow-snapshot]]\n  - **[[resource.node-component.flow.node-metadata]]**: System-related administrative and structural metadata for mesh nodes\n  - **[[Version datasets|resource.node-component.flow-snapshot.version]]**: Versioned snapshots of datasets\n- **[[next snapshots|resource.node-component.flow-snapshot.next]]**: Draft workspaces for ongoing changes to versioned datasets\n- **[[Node handles|resource.node-component.node-handle]]**: Components that provide referential indirection, allowing references to nodes as mesh resources rather than their referents\n- **[[Asset trees|resource.node-component.asset-tree]]**: Collections of arbitrary files and folders attached to the mesh\n\n#### Files\n\nTerminal [[mesh resources|resource]] that cannot contain other resources:\n\n- **[[Resource pages|resource.node-component.documentation-resource.resource-page]]**: index.html files present in every mesh folder after weaving\n- **[[Distribution files|resource.node-component.snapshot-distribution]]**: Data files in various RDF formats\n- **README.md and CHANGELOG.md**: Documentation files providing context\n\n\n## Physical Structure\n\n### Folder Mapping\n- Mesh nodes correspond physically to [[mesh folders|facet.filesystem.folder]]\n- Folder names become namespace segments and URL path components\n- The local [[concept.identifier.intramesh]] for a node matches its containing folder name\n\n### File Organization\n- [[Datasets|facet.resource.dataset]] are represented by folders containing at least one distribution file\n- Distribution files must be named using the dataset's [[namespace segment|concept.namespace.segment]]\n- Resource pages (index.html) should be present in every mesh folder after [[weaving|concept.weave-process]]\n\n### Reserved Names\n- All reserved folder names begin with an underscore (_)\n- Examples: `_assets/`, `_meta-flow/`, `_current`, `_next`\n\n## Logical Structure\n\n### Namespace Extension\n- Mesh folders always extend the namespace with a segment corresponding to the folder name\n- This creates a hierarchical URL structure for addressing resources\n- Each resource has a unique [[Intramesh|concept.identifier.intramesh]] based on its path and local name\n\n### Containment Rules\n- **Mesh nodes** are always containers of components (i.e., at least [[resource.node-component.flow.node-metadata]] and [[concept.mesh.resource.folder._node-handle]]) and potentially containers of other nodes \n  - **bare nodes**: no additional containment requirements\n  - **data nodes**: must have [[resource.node-component.flow.data]] with at least one distribution\n- **Asset tree components**: Cannot contain nodes\n- all components can contain \n\n## Rules & Constraints\n\n### System vs User Boundaries\n- **System components**: Generated and managed by the weave process, not intended for user modification\n- **User components**: Directly modifiable by users ([[resource.node-component.flow-snapshot.current]], README.md, CHANGELOG.md)\n- The weave process maintains system components and generates missing required flows\n\n### Versioning Requirements\n- flow versioning is managed through the [[Versioning|concept.versioning]] system\n  - turning versioning on and off is controlled in the [[resource.node-component.node-config-defaults]]\n  - Version history is realized in [[resource.node-component.flow-snapshot.version]] with numbered version snapshots\n  - Version history metadata is kept in the node's [[resource.node-component.flow.node-metadata]]\n\n### Addressing Requirements\n- Every mesh resource must be addressable via its URL path\n- URLs must return meaningful content when dereferenced\n  - [[resource.node-component.documentation-resource.resource-page]] provide human-readable information for [[facet.filesystem.folder]]-based resources\n    - resource pages are always index.html files generated by \"on weave\" from the [[resource.node-component.documentation-resource.changelog]] and [[resource.node-component.documentation-resource.readme]] [[resource.node-component.documentation-resource]], templates in [[resource.node-component.asset-tree]] and any scoped template mappings specified in [[resource.node-component.node-config-defaults]] files \n  - [[facet.filesystem.file]]\n\n## Integration Points\n\n### Weave Process\nThe [[Weave Process|concept.weave-process]] process maintains mesh integrity by:\n- Checking for required system resources and creating them if missing\n- Generating resource pages for changed resources\n- Managing dataset versioning and metadata\n- Ensuring all resources remain addressable and dereferenceable\n\n### Publishing Workflow\n- Meshes are designed to be served directly as static sites\n- GitHub Pages integration allows immediate publishing after repository updates\n- No static site generator required, though resource page generation occurs during weaving\n- The repository structure directly maps to the published URL structure\n\n### Dataset Integration\nMeshes support multiple RDF formats and follow [[DCAT v3|related-topics.dcat.vocabulary]] standards for dataset organization. [[Datasets|facet.resource.dataset]] within meshes include both standalone datasets and those embedded as node components.\n","n":0.038}}},{"i":124,"$":{"0":{"v":"submesh","n":1}}},{"i":125,"$":{"0":{"v":"Embedded Mesh","n":0.707},"1":{"v":"\n- a mesh whose [[concept.root-node]] is not locate at the top of the repo, i.e., it share the repo with other files.\n","n":0.213}}},{"i":126,"$":{"0":{"v":"Assets","n":1},"1":{"v":"\nEverything file in an [[folder._assets]] (or its subfolders) is considered an asset.\n\nEven though they will have a URL in the [[concept.namespace.base]], they are not considered \"mesh resources\".\n\n## Special Assets\n\nPrefixed with an underscore, these assets have a special role to play in the \"weave process\"\n\n\n### _weave-config.jsonld\n\n","n":0.149}}},{"i":127,"$":{"0":{"v":"mesh repo","n":0.707},"1":{"v":"\nA Semantic Flow mesh repository (or mesh repo for short) is a git repository that contains a [[concept.root-node]] at the top of the repo, and any number of additional, contained [[resource.node]]\n\n\n## Github Repos\n\n- can either be \"username/org pages repository\"\" (which automatically hosts content at the namesake url, so maybe call it a namesake repository, e.g. djradon.github.io) or 2nd-level (corresponding to an owned repo)\n- a 'docs' folder that contains the generated sf site\n    - within 'docs' there's a folder for each namespace\n  \n## Questions\n\n- can you include a mesh in an existing repo?\n  - Sure!\n  - but for composability (i.e., linking a repo into an existing mesh) you need an unbroken chain, so embedding a root mesh below the top of a repo might make it harder for people to re-use. \n","n":0.087}}},{"i":128,"$":{"0":{"v":"IRI","n":1},"1":{"v":"\nOn the semantic web, resources (things you might want to talk about with RDF statements) are identified with Internationalized Resource Identifiers. Traditionally, IRIs don't necessarily LOCATE a resource, i.e., if you put them in a web browser, they don't necessarily return content.\n\nBut in the Semantic Flow, all IRIs return a web page. \n\nSee [[faq.reference-iri-choices]] for a discussion of IRI types. \n\n","n":0.128}}},{"i":129,"$":{"0":{"v":"Immutability","n":1},"1":{"v":"\nImmutable data provides fundamental guarantees that enable reliable, distributed, and concurrent systems. But immutability clashes with document-oriented data the updates slowly and in chunks.\n\n- [[resource.node-component.flow-snapshot.version]] (e.g. in [[folder._vN]]) should be treated as immutable. If you need to refer to the current dataset \"as is\", you should refer to its corresponding dataset version.\n- sometimes, e.g., for compliance reasons, you have to hard delete a resource (as opposed to just tombstoning it, a soft delete), or even modifying it. \n  - [[hashes|sflo.feature.changing-historical-datasets]] can be used to detect mutations\n\n## References\n\nhttps://s11.no/2013/prov/resources-that-change-state/","n":0.107}}},{"i":130,"$":{"0":{"v":"identifier","n":1},"1":{"v":"\n\n\n\n## Identifier references in Semantic Flow\n\n| Semantic Flow resource type            | referent                       | [[concept.identifier.intramesh]]                    |\n| -------------------------------------- | ------------------------------ | --------------------------------------------------- |\n| bare node                              | -nothing, (yet)                | `ns/`                                               |\n| data node                              | abstract dataset               | `ns/djradon-bio/`                                   |\n| abstract dataset (flow)                | dataset series                 | `ns/djradon-bio/_data-flow/`                        |\n| concrete node dataset (snapshot)       | concrete data dataset          | `ns/djradon-bio/_data-flow/_next/`                  |\n| distribution                           | content / dataset distribution | `ns/djradon-bio/_data-flow/_v1/dave-bio_v1.trig`    |\n| abstract meta dataset (flow)           | node metadata dataset series   | `ns/djradon-bio/_meta-flow/`                        |\n| concrete meta dataset (snapshot)       | node metadata dataset          | `ns/djradon-bio/_meta-flow/_current/`               |\n| abstract operational config (flow)     | operational config series      | `ns/djradon-bio/_config-operational-flow/`          |\n| concrete operational config (snapshot) | operational config             | `ns/djradon-bio/_config-operational-flow/_current/` |\n| abstract inheritable config (flow)     | inheritable config series      | `ns/djradon-bio/_config-inheritable-flow/`          |\n| concrete inheritable config (snapshot) | inheritable config             | `ns/djradon-bio/_config-inheritable-flow/_current/` |\n| handle                                 | mesh node                      | `ns/djradon/_node-handle/`                          |\n| resource documentation                 | resource page (content)        | `ns/djradon/index.html`                             |\n| resource documentation                 | README file (content)          | `ns/djradon/README.md`                              |\n| asset tree                             | collection of assets           | `ns/assets/`                                        |\n| asset folder                           | sub-collection of assets       | `ns/assets/images/`                                 |\n| asset                                  | content / image                | `ns/assets/images/logo.svg`                         |\n\n\nExample:\n- `ns/` = bare node for organizing content and minting IRIs; refers to itself as a namespace\n- `ns/dave/` = refers to Dave the person (data node)\n- `ns/dave/index.html` = resource page about Dave (content)\n- `ns/dave-bio/` = refers to Dave's biographical dataset (data node)\n- `ns/dave-bio/_data-flow/` = abstract dataset (DatasetSeries) containing Dave's bio data\n- `ns/dave-bio/_data-flow/_current/` = current concrete dataset snapshot\n- `ns/dave-bio/_data-flow/_v1/dave-bio_v1.trig` = RDF distribution from version 1\n- `ns/dave/_assets/images/dave-headshot.jpg` = an image asset; \"attached\" to the mesh, but not a mesh resource\n\n### Terminology note: “data dataset”\n\n- “Abstract data dataset” = the DatasetSeries at `_data-flow/`.\n- “Concrete data dataset” = a snapshot under `_data-flow/` (e.g., `_current/`, `_vN/`).\n- Only distributions (`*.trig`, `*.jsonld`, etc.) are retrievable content files.\n\n\n## URL Senses\n\n### **Content URLs**\n\nURLs that point to **concrete information resources** (files on disk or over HTTP):\n\n* **Distribution URLs** → materialized datasets, e.g. `test.ttl`, `dave_v1.jsonld`, etc.\n* **Resource page URLs** → e.g. `index.html`\n* **Resource documentation URLs** → e.g. `README.md`, `CHANGELOG.md`\n* **Asset URLs** → e.g. `.png`, `.css`, `.js`\n\nThese are *retrievable representations* (materialized content).\n\n---\n\n### **Concept URLs**\n\nURLs that refer to **concepts, entities, or abstract things**, including:\n\n* **bare node URLs** → Organizational containers\n* **data node URLs** → Concepts with associated datasets\n* **Abstract dataset URLs** → Dataset-as-persistent-concept\n* **Concrete dataset URLs** → Specific dataset snapshots\n* **Handle URLs** → Mesh node identities\n\n\n### URL Pattern Semantics\n\n| URL Type    | Trailing Slash? | Refers to…                    | Example                                 |\n| ----------- | --------------- | ----------------------------- | --------------------------------------- |\n| Content URL | No              | A fetchable document or asset | `https://example.org/ns/foo/index.html` |\n| Concept URL | Yes (`/`)       | A real-world or mesh concept  | `https://example.org/ns/foo/`           |\n\nEven though you might be tempted to think of a datasets as concrete things, the URLs for data nodes, abstract datasets, and concrete datasets all refer to concepts, i.e., **non-retrievable entities**. Only Distribution URLs refer to downloadable data, i.e., dataset distributions.\n\n### Why referent matters\n\nUnderstanding what a URL refers to is crucial for proper semantic web implementation. In the past, people have tried to use content URLs to represent the things they refer to. A classic example is using `http://example.org/person.html` to identify a person, when it actually identifies an HTML document about the person. This conflation creates semantic ambiguity and breaks linked data principles.\n\nSemantic Flow enforces clear referent distinctions through URL patterns: slash-terminated URLs always refer to concepts or entities, while extension-terminated URLs always refer to retrievable content. This prevents the classic \"document vs thing\" confusion that has plagued semantic web implementations.\n\n## Namespace-relative basing\n\nsee [[concept.namespace-relative-basing]]\n","n":0.042}}},{"i":131,"$":{"0":{"v":"intramesh identifier","n":0.707},"1":{"v":"\nIntramesh identifiers are like base-relative URIs (i.e., without the scheme, e.g., https:// or file://) except may not include fragments (#) or query separators (?). They correspond to the filesystem location of their corresponding resources. Intramesh identifiers are recorded within distributions and, where configuration is needed, under the node’s operational config flow. Paths are always resolved relative to the distribution file that declares them.\n\nIf it starts with a `../` it refers to the parent, `../../` refers to the grandparent, etc.\n\n## Identifier Semantics\n\nIdentifiers have the same semantics as [[concept.identifier]]\n\n## Identifier Name Limitations\n\n- initial underscores prefix all reserved dataset identifiers and should be avoided in general\n![[sflo#^pnoqpr3ff4za]] \n\n## Examples\n\nDirectory structure: node/flow/snapshot/distribution.trig\n\nOperational config example: `my-dataset/_config-operational-flow/_current/config.trig`  \nInheritable config example: `my-dataset/_config-inheritable-flow/_current/config.trig`  \nMeta-flow example: `my-dataset/_meta-flow/_current/meta.trig`\n\nIntramesh identifiers from meta-flow distributions:\n\nNode self-reference: `\"../../../my-dataset\"`  \nOther flows: `\"../../_config-operational-flow/_current/config.trig\"`, `\"../../_config-inheritable-flow/_current/config.trig\"`, `\"../../_data-flow/_current/data.jsonld\"`  \nComponents in other flows: Same pattern, just different flow names\n","n":0.085}}},{"i":132,"$":{"0":{"v":"Mesh CRUD","n":0.707},"1":{"v":"\n## Operational Modalities\n\n**A. Manual Manipulation**\n- Pre-built node folder structures with user-editable flows and other components\n- Manual mesh resource creation (nodes; flows, snapshots, distributions and other components)\n- File-system based editing workflows\n- Validation of hand-crafted mesh structures\n\n**B. API-Driven Node Manipulation**\n- Flow-service API endpoints for programmatic node creation\n- Support for root node initialization\n- Flow and other component management via API\n- RESTful mesh resource manipulation\n\n**C. Dataset Distribution Upload + Extraction**\n- Upload mechanisms for RDF dataset distributions (.trig, .jsonld, etc.)\n- Automatic named entity extraction from semantic data\n- System-generated reference and data nodes\n- Batch processing of semantic data\n- **Limitation**: Cannot handle binary file resources (audio, images, etc.) - only RDF data\n- File resources must be handled via Direct Manual Construction or API-Driven modalities\n","n":0.092}}}]}

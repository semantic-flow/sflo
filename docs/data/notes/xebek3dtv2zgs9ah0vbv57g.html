<h1 id="developer-general-guidance">Developer General Guidance<a aria-hidden="true" class="anchor-heading icon-link" href="#developer-general-guidance"></a></h1>
<h2 id="agent-specific-instructions">Agent-specific Instructions<a aria-hidden="true" class="anchor-heading icon-link" href="#agent-specific-instructions"></a></h2>
<ul>
<li>See <a href="/sflo/notes/concept-summary">Concept Summary</a> for a conceptual overview. See <a href="/sflo/notes/f0g7d31ivgn6rgllncdwep8">Memory Bank</a> for CRITICAL information for AI agents.</li>
<li>agents should re-use terminals instead of starting a new one for each command</li>
</ul>
<h2 id="workspace-layout">Workspace layout<a aria-hidden="true" class="anchor-heading icon-link" href="#workspace-layout"></a></h2>
<h3 id="sflo-monorepo">sflo monorepo<a aria-hidden="true" class="anchor-heading icon-link" href="#sflo-monorepo"></a></h3>
<pre><code>sflo/
  cli/                        # the sflo command-line application; consumes the sflo-api
  plugins/
    api-docs/                 # api documentation/playground (probably stoplight Elements)
    mesh-server/              # static mesh server(s)
    sflo-web/                 # your web UI, if you want it as a plugin
    sflo-api/                 # OpenAPI REST endpoint, used by CLI and sflo-web
    sparql-ro/                # SPARQL read-only endpoint 
    sparql-update/            # SPARQL write-capable endpoint
    sparql-editor/            # SIB Swiss editor at /play
  sflo-host/                  # the big service that loads plugins
  shared/
    core/                     # RDFine/LDKit, SHACL, types
    auth/                     # JWT + GitHub device flow
    config/                   # runtime/config loaders (RDF/JSON)
    sparql/                   # used by sparql-ro and sparql-update  (provided by Comunica)
    utils/                    # misc helpers
  tests/                      # cross-application tests
    e2e/                     # cross-app: start real service, hit via CLI/web
    contracts/               # Pact or OpenAPI contract tests
    perf/                    # k6/Artillery scenarios (optional)
    fixtures/                # shared data sets and seed scripts

</code></pre>
<h3 id="other-workspace-components">Other Workspace Components<a aria-hidden="true" class="anchor-heading icon-link" href="#other-workspace-components"></a></h3>
<ul>
<li><strong>ontology/</strong>: repo containing relevant ontologies:
<ul>
<li><code>semantic-flow</code> - main ontology (sflo/ontology/semantic-flow/_data-flow/_working/semantic-flow-ontology.ttl) defines meshes and their nodes and components; </li>
<li><code>node-config</code> - Configuration properties that apply directly to mesh entities (nodes, flows, snapshots, etc.)</li>
<li><code>meta-flow</code> - provenance and licensing vocabulary</li>
<li><code>sflo-service</code> - Service layer configuration vocabulary for the flow-service application</li>
<li>Ontologies are kept in a separate repository, but for development purposes are nested into the monorepo under ontology/ directory for ease of access. </li>
</ul>
</li>
<li><strong>test-ns/</strong>: repo containing a test namespace</li>
</ul>
<h2 id="developer-workflow">Developer Workflow<a aria-hidden="true" class="anchor-heading icon-link" href="#developer-workflow"></a></h2>
<h3 id="buildwatch">Build/Watch<a aria-hidden="true" class="anchor-heading icon-link" href="#buildwatch"></a></h3>
<ul>
<li>The development workflow requires two terminals running concurrently:</li>
<li><strong>Terminal 1</strong>: Run <code>pnpm dev:watch</code> to start the TypeScript compiler in watch mode. This will watch all packages and rebuild them on change.</li>
<li><strong>Terminal 2</strong>: Run <code>pnpm dev</code> to start the <code>nodemon</code> server, which will automatically restart when the built files in the <code>dist</code> directories are updated.</li>
<li>This setup ensures that changes in any package are automatically compiled and that the server restarts with the latest code.</li>
<li>Keep inter-package imports as package specifiers; avoid deep source imports across packages.</li>
</ul>
<h3 id="hot-reload">Hot Reload<a aria-hidden="true" class="anchor-heading icon-link" href="#hot-reload"></a></h3>
<p>The development setup includes automatic hot reload using nodemon:</p>
<ul>
<li><strong>Watches</strong>: <code>sflo-host/src</code>, <code>plugins/*/src</code>, <code>shared/*/src</code></li>
<li><strong>Auto-restarts</strong> when any watched file changes</li>
<li><strong>Loads plugins from source</strong> in development mode (not built <code>dist</code> files)</li>
<li><strong>Preserves debugger connection</strong> after restart</li>
</ul>
<h3 id="building-the-docs">Building the docs<a aria-hidden="true" class="anchor-heading icon-link" href="#building-the-docs"></a></h3>
<pre class="language-shell"><code class="language-shell">npx dendron publish <span class="token builtin class-name">export</span> --target github --yes
</code></pre>
<h2 id="rdf-and-semantic-web">RDF and Semantic Web<a aria-hidden="true" class="anchor-heading icon-link" href="#rdf-and-semantic-web"></a></h2>
<ul>
<li>prefer JSON-LD for all RDF instance data and ontologies, as Turtle doesn't support slash-terminated CURIEs, and we use a trailing slash to delineate between files and resource names.</li>
<li>terminate non-file IRIs with a slash (solves the httprange-14 problem)</li>
<li>avoid use of blank nodes</li>
<li>prefer relative/local URIs for transposability/composability</li>
<li>be mindful of RDF terminology and concepts
<ul>
<li>extends DCAT for dataset catalogs</li>
<li>extends PROV for provenance, with relator-based contexts</li>
</ul>
</li>
<li>RDF comments should be extremely concise and clear.</li>
</ul>
<h3 id="denormalization">Denormalization<a aria-hidden="true" class="anchor-heading icon-link" href="#denormalization"></a></h3>
<ul>
<li>when speed matters and the query is complicated, use a derived, join-free representation of a portion of the data, optimized for lookup speed.</li>
</ul>
<h3 id="ontology-patterns">Ontology patterns<a aria-hidden="true" class="anchor-heading icon-link" href="#ontology-patterns"></a></h3>
<ul>
<li>use <strong>SHACL constraints</strong> for JSON-LD validation when working with semantic data; </li>
<li>avoid rdfs:domain and rdfs:range; prefer schema:domainIncludes and schema:rangeIncludes  for maximum re-use flexibility</li>
<li>specify preferred 3rd-party property vocabulary with sh:property, even if sh:minCount is 0</li>
</ul>
<h2 id="coding-standards">Coding Standards<a aria-hidden="true" class="anchor-heading icon-link" href="#coding-standards"></a></h2>
<h3 id="language--runtime">Language &#x26; Runtime<a aria-hidden="true" class="anchor-heading icon-link" href="#language--runtime"></a></h3>
<ul>
<li><strong>TypeScript</strong>: Use strict TypeScript configuration with "Pure ESM" modern ES2022+ features; NO CJS </li>
<li>Use NodeJS v24 and the latest best practices</li>
<li>If using any is actually clearer than not using it, it's okay</li>
<li>Use <code>satisfies</code> whenever you're writing a literal config object that should be checked against a TypeScript shape, but you want to retain the full type of the literal for use in your program.</li>
<li>use type-only imports for types, since verbatimModuleSyntax is enabled</li>
</ul>
<h3 id="rdf-data-handling">RDF Data Handling<a aria-hidden="true" class="anchor-heading icon-link" href="#rdf-data-handling"></a></h3>
<ul>
<li><strong>Primary Format</strong>: .jsonld files for RDF data storage and processing</li>
<li><strong>Secondary Format</strong>: Full JSON-LD support required</li>
<li><strong>RDF Libraries</strong>: Use RDF.js ecosystem libraries consistently across components</li>
<li><strong>Namespace Management</strong>: Follow IRI-based identifier patterns as defined in <code>sflo.concept.identifier.md</code></li>
<li><strong>Reserved Names</strong>: Validate against underscore-prefixed reserved identifiers per <code>sflo.concept.identifier.md</code></li>
<li>The most effective validation strategy combines TypeScript structural validation with RDF semantic validation:</li>
</ul>
<h2 id="documentation-driven-development">Documentation-Driven Development<a aria-hidden="true" class="anchor-heading icon-link" href="#documentation-driven-development"></a></h2>
<ul>
<li>unclear, missing, or overly-verbose documentation must be called out</li>
<li>documentation should be wiki-style: focused on the topic at hand, don't repeat yourself, keep it as simple as possible </li>
<li>to encourage documentation-driven software engineering, code comments should refer to corresponding documentation by filename, and the documentation and code should be cross-checked for consistency whenever possible</li>
</ul>
<h3 id="documentation-architecture">Documentation Architecture<a aria-hidden="true" class="anchor-heading icon-link" href="#documentation-architecture"></a></h3>
<p>Project documentation, specifications, and design choices are stored in <code>documentation/</code> using Dendron's hierarchical note system. Key documentation hierarchies include:</p>
<ul>
<li>
<p><strong>Concepts</strong>: <code>concept.*</code> files talk about general Semantic Flow concepts</p>
</li>
<li>
<p><strong>Mesh resource docs</strong>: <code>mesh-resource.*</code> files define the semantic mesh architecture</p>
</li>
<li>
<p><strong>Product specifications</strong>: <code>product.*</code> files detail each component</p>
</li>
<li>
<p><strong>Use cases</strong>: <code>use-cases.*</code> for feature planning and testing</p>
</li>
<li>
<p>docs are in markdown, with wiki-flavored links</p>
<ul>
<li>link names can be specified with <code>[[link name|file]]</code></li>
</ul>
</li>
<li>
<p>Dendron handles the frontmatter</p>
<ul>
<li>don't rewrite IDs in the frontmatter</li>
<li>agents should ask a human to create new documentation files</li>
</ul>
</li>
</ul>
<h3 id="code-comments">Code Comments<a aria-hidden="true" class="anchor-heading icon-link" href="#code-comments"></a></h3>
<ul>
<li><strong>Reference docs from code</strong>: reference corresponding documentation by filename (e.g., <code>// See sflo.concept.mesh.resource.node.md</code>)</li>
<li><strong>Interface Definitions</strong>: Link to concept documentation</li>
<li><strong>Cross-Reference Validation</strong>: Ensure consistency between code and documentation; if docs need updating, call it out</li>
</ul>
<h2 id="file-organization--naming">File Organization &#x26; Naming<a aria-hidden="true" class="anchor-heading icon-link" href="#file-organization--naming"></a></h2>
<ul>
<li><strong>TypeScript Modules</strong>: Use <code>.ts</code> extension, organize by feature/component</li>
<li><strong>Test Files</strong>:
<ul>
<li>unit test files go in application-name/src/tests/unit/ using <code>.test.ts</code> suffix</li>
<li>intra-package integration tests go in application-name/src/tests/integration/ using <code>.test.ts</code> suffix</li>
<li>inter-package e2e tests go in tests/e2e/</li>
</ul>
</li>
<li><strong>Mesh Resources</strong>: Follow mesh resource naming conventions from <a href="/sflo/notes/0n1lq6aq1gskj46bpcx9h4h#filenaming-per-snapshot">Filenaming Per Snapshot</a></li>
<li><strong>Constants</strong>: Use UPPER_SNAKE_CASE for constants, especially for reserved names; centralize constants, e.g. shared/src/mesh-constants.ts</li>
<li><strong>File size</strong>: For ease of AI-based editing, prefer lots of small files over one huge file</li>
<li><strong>Quoting</strong>: For easier compatibility with JSON files, use double quotes everywhere</li>
</ul>
<h3 id="import-path-policy">Import Path Policy<a aria-hidden="true" class="anchor-heading icon-link" href="#import-path-policy"></a></h3>
<ul>
<li>
<p>Inter-package imports (between workspace packages):</p>
<ul>
<li>Use workspace package specifiers.</li>
<li>Examples:
<ul>
<li><code>import { startHost } from "@semantic-flow/host"</code></li>
<li><code>import { loadConfig } from "@semantic-flow/config"</code></li>
</ul>
</li>
<li>Rationale:
<ul>
<li>Keeps package boundaries clear and publish-ready</li>
<li>pnpm resolves to local workspace packages during development, so you get your local builds—not the registry</li>
<li>Compatible with build/watch flows and CI</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Intra-package imports (within a single package):</p>
<ul>
<li>Use the <code>@</code> alias mapped to that package’s <code>src/</code> root to avoid relative path chains.</li>
<li>Example (inside a package): <code>import { something } from "@/features/something"</code></li>
<li>Configuration (per package tsconfig):
<ul>
<li><code>"compilerOptions": { "baseIRI": "src", "paths": { "@/*": ["*"] } }</code></li>
</ul>
</li>
<li>Tooling notes:
<ul>
<li>For Node/tsx/Vitest, ensure your runner resolves TS path aliases (e.g., <code>tsconfig-paths/register</code> or vite-tsconfig-paths).</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Publishing:
<ul>
<li>Each package should export built entry points (e.g., <code>dist/</code>) via <code>exports</code>/<code>module</code>/<code>types</code>. The same import paths work identically in dev and prod.</li>
</ul>
</li>
</ul>
<h2 id="system-architecture">System Architecture<a aria-hidden="true" class="anchor-heading icon-link" href="#system-architecture"></a></h2>
<h3 id="quadstore">Quadstore<a aria-hidden="true" class="anchor-heading icon-link" href="#quadstore"></a></h3>
<ul>
<li>For testability and in case we ever want to use multiple stores simultaneously, store-accessing functions take a QuadstoreBundle</li>
<li>quadstore API calls use "undefined" instead of "null" to represent the wildcard for subjects, predicates, objects, and graphs</li>
</ul>
<h3 id="configuration-architecture">Configuration Architecture<a aria-hidden="true" class="anchor-heading icon-link" href="#configuration-architecture"></a></h3>
<ul>
<li>The project uses a sophisticated JSON-LD based configuration system with multiple layers</li>
<li><strong>Service Configuration resolution order</strong>: CLI arguments → Environment variables → Config file → Defaults</li>
<li>The <a href="/sflo/../semantic-flow/flow-service/src/config/defaults.ts"><code>defaults.ts</code></a> file is the source for "platform default" configuration</li>
</ul>
<h3 id="logging-and-error-system-architecture">Logging and Error System Architecture<a aria-hidden="true" class="anchor-heading icon-link" href="#logging-and-error-system-architecture"></a></h3>
<ul>
<li><strong>Structured logging</strong> with rich <code>LogContext</code> interface is the preferred approach</li>
<li><strong>Three-channel logging architecture</strong>:
<ul>
<li>Console logging (pretty format for development)</li>
<li>File logging (pretty format for human readability)</li>
<li>Sentry logging (structured JSON for error tracking)</li>
</ul>
</li>
<li><strong>Graceful degradation principle</strong>: Logging failures should never crash the application</li>
</ul>
<h4 id="error-handling">Error Handling<a aria-hidden="true" class="anchor-heading icon-link" href="#error-handling"></a></h4>
<ul>
<li><strong>Custom Errors</strong>: Create semantic mesh-specific error types</li>
<li><strong>Logging</strong>: Use structured logging for debugging weave operations</li>
<li><strong>Async Error Propagation</strong>: Properly handle async/await error chains</li>
</ul>
<h4 id="enhanced-error-handling-with-logcontext">Enhanced Error Handling with LogContext<a aria-hidden="true" class="anchor-heading icon-link" href="#enhanced-error-handling-with-logcontext"></a></h4>
<p>The platform uses <strong>LogContext-enhanced error handling</strong> from <code>shared/src/utils/logger/error-handlers.ts</code> for consistent error logging across all components. Both error handling functions now accept optional <code>LogContext</code> parameters for rich contextual information.</p>
<p><strong>Core Functions:</strong></p>
<ul>
<li><code>handleCaughtError()</code> - For caught exceptions with comprehensive error type handling</li>
<li><code>handleError()</code> - For controlled error scenarios with structured messaging</li>
</ul>
<h4 id="logcontext-structure">LogContext Structure<a aria-hidden="true" class="anchor-heading icon-link" href="#logcontext-structure"></a></h4>
<h4 id="handlecaughterror-examples">handleCaughtError Examples<a aria-hidden="true" class="anchor-heading icon-link" href="#handlecaughterror-examples"></a></h4>
<p><strong>Startup Error Handling:</strong></p>
<p>This pattern ensures <strong>uniform error reporting</strong> with rich contextual information, <strong>easier debugging</strong> through structured logging, and <strong>consistent integration</strong> with console, file, and network logging tiers.</p>
<h3 id="testing">Testing<a aria-hidden="true" class="anchor-heading icon-link" href="#testing"></a></h3>
<ul>
<li><strong>Unit Tests</strong>: target ≥80% critical-path coverage and include both success and failure cases.</li>
<li><strong>Integration Tests</strong>: Test mesh operations end-to-end; tests are located in tests/integration/ dir</li>
<li><strong>RDF Validation</strong>: Test both .trig and JSON-LD parsing/serialization</li>
<li><strong>Mock Data</strong>: Create test mesh structures following documentation patterns</li>
<li>after you think you've completed a task, check for any "problems", i.e., deno-lint</li>
</ul>
<h4 id="what-to-place-where">What to Place Where<a aria-hidden="true" class="anchor-heading icon-link" href="#what-to-place-where"></a></h4>
<ul>
<li>
<p>Package integration if it targets that package’s boundaries only.</p>
<ul>
<li>Examples: service repo + DB, CLI command against a mock server, web page with MSW.</li>
</ul>
</li>
<li>
<p>Top-level e2e if it requires two or more apps running together or real infra.</p>
<ul>
<li>Examples: CLI → API → DB, web → API auth, migration rollout checks.</li>
</ul>
</li>
</ul>
<h3 id="performance">Performance<a aria-hidden="true" class="anchor-heading icon-link" href="#performance"></a></h3>
<ul>
<li><strong>RDF Processing</strong>: Stream large RDF files where possible</li>
<li><strong>File I/O</strong>: Use async file operations consistently</li>
</ul>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/sflo/notes/g97elh6q5bszy2c74gsmuqk">2025 11 03 Optimizing for Agents</a></li>
<li><a href="/sflo/notes/f0g7d31ivgn6rgllncdwep8">Memory Bank</a></li>
</ul>
{"pageProps":{"note":{"id":"i9v5cbqq2zqfhrjcolq48df","title":"Patterns","desc":"","updated":1762362594560,"created":1762221503576,"custom":{},"fname":"dev.patterns","type":"note","vault":{"fsPath":"documentation","selfContained":false,"name":"sflo"},"contentHash":"50df53414226af3de68383353a547b57","links":[{"type":"wiki","from":{"fname":"dev.patterns","id":"i9v5cbqq2zqfhrjcolq48df","vaultName":"sflo"},"value":"dev.logging-and-error-handling","position":{"start":{"line":115,"column":5,"offset":4016},"end":{"line":115,"column":39,"offset":4050},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"dev.logging-and-error-handling"}},{"from":{"fname":"todo","id":"xqjr13fyons9goxv8rjrskj","vaultName":"sflo"},"type":"backlink","position":{"start":{"line":24,"column":25,"offset":898},"end":{"line":24,"column":41,"offset":914},"indent":[]},"value":"dev.patterns"},{"from":{"fname":"task.2025-11-03-optimizing-for-agents","id":"g97elh6q5bszy2c74gsmuqk","vaultName":"sflo"},"type":"backlink","position":{"start":{"line":20,"column":3,"offset":918},"end":{"line":20,"column":19,"offset":934},"indent":[]},"value":"dev.patterns"}],"anchors":{"development-patterns":{"type":"header","text":"Development Patterns","value":"development-patterns","line":8,"column":0,"depth":1},"architectural-patterns":{"type":"header","text":"Architectural Patterns","value":"architectural-patterns","line":12,"column":0,"depth":2},"comunica-sparql-vs-quadstore-primitives-for-data-access":{"type":"header","text":"Comunica SPARQL vs Quadstore Primitives for data access","value":"comunica-sparql-vs-quadstore-primitives-for-data-access","line":14,"column":0,"depth":3},"stream-patterns":{"type":"header","text":"Stream Patterns","value":"stream-patterns","line":59,"column":0,"depth":3},"error-handling-and-logging-system-patterns":{"type":"header","text":"Error Handling and Logging System Patterns","value":"error-handling-and-logging-system-patterns","line":119,"column":0,"depth":3}},"children":[],"parent":"8lbblgh43pkx93frnrb48qq","data":{}},"body":"<h1 id=\"patterns\">Patterns<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#patterns\"></a></h1>\n<h1 id=\"development-patterns\">Development Patterns<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#development-patterns\"></a></h1>\n<p>This document captures recurring architectural and code patterns used throughout the Semantic Flow project.</p>\n<h2 id=\"architectural-patterns\">Architectural Patterns<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#architectural-patterns\"></a></h2>\n<h3 id=\"comunica-sparql-vs-quadstore-primitives-for-data-access\">Comunica SPARQL vs Quadstore Primitives for data access<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#comunica-sparql-vs-quadstore-primitives-for-data-access\"></a></h3>\n<p>Both can win. Pick by query shape.</p>\n<p>Use Quadstore primitives (<code>get</code>, <code>getStream</code>, <code>match</code>) when:</p>\n<ul>\n<li>One or two triple patterns with fixed IRIs/literals.</li>\n<li>You can drive lookups by known keys and stop early.</li>\n<li>You need strict control over streaming, batching, or a read-modify-write cycle.</li>\n<li>You want zero SPARQL parse/plan overhead.</li>\n</ul>\n<p>Use SPARQL via Comunica when:</p>\n<ul>\n<li>Three or more patterns with joins, OPTIONAL/UNION, FILTER, ORDER BY, GROUP BY, LIMIT.</li>\n<li>You’d benefit from join reordering, filter/projection pushdown, and early result streaming.</li>\n<li>You might federate later or swap sources without rewriting app code.</li>\n</ul>\n<p>Why primitives can be faster on “simple”:</p>\n<ul>\n<li>Direct index hits with no planner cost.</li>\n<li>Tight loops with <code>for await...of</code> and immediate early-exit.</li>\n<li>You can pre-narrow with exact keys or prefix scans and avoid any join at all.</li>\n</ul>\n<p>A practical split for internal data access:</p>\n<ul>\n<li>“Path to one thing” lookups (by IRI, by type, by id): primitives.</li>\n<li>Graph navigation with 3+ hops or any aggregation/sorting: SPARQL.</li>\n</ul>\n<p>Hybrid patterns that work well:</p>\n<ul>\n<li>Use primitives to fetch candidate IRIs, then pass them into a SPARQL <code>VALUES</code> clause.</li>\n<li>Pre-materialize small “views” (denormalized quads) you hit often, then query them with SPARQL.</li>\n<li>Keep SPARQL templates for common shapes; fall back to primitives for hot key-lookups.</li>\n</ul>\n<p>Implementation notes:</p>\n<ul>\n<li>Consume streams with <code>for await (const q of stream)</code>; await completion at the boundary with <code>stream/promises</code> <code>finished()</code> or <code>pipeline()</code>.</li>\n<li>Reuse a single Comunica engine instance to amortize init cost.</li>\n<li>With Quadstore, structure data so frequent lookups align with available index permutations; primitives shine when you can select by the leading fields.</li>\n</ul>\n<p>Rule of thumb:</p>\n<ul>\n<li>Simple, key-oriented, latency-sensitive ⇒ primitives.</li>\n<li>Anything with joins/options/ordering/aggregation ⇒ SPARQL.</li>\n</ul>\n<h3 id=\"stream-patterns\">Stream Patterns<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#stream-patterns\"></a></h3>\n<p>Use async/await for boundaries (start/finish), and use async iteration for the stream body.</p>\n<ul>\n<li>\n<p>Promises: use <code>await</code> for file I/O (<code>fs/promises</code>), HTTP fetches, initialization, and “collect-all” helpers that intentionally materialize results.</p>\n</li>\n<li>\n<p>Streaming RDF (RDF/JS, Comunica, rdf-parse/serialize, rdf-ext):</p>\n<ul>\n<li>\n<p>Prefer async iterators:</p>\n<pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// quadStream implements AsyncIterable&#x3C;Quad></span>\n<span class=\"token keyword control-flow\">for</span> <span class=\"token keyword control-flow\">await</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> quad <span class=\"token keyword\">of</span> quadStream<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// process quad</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>This gives proper backpressure. Do not <code>.on('data', ...)</code> and <code>await</code> inside the handler.</p>\n</li>\n<li>\n<p>If a sink uses RDF/JS <code>Sink#import(source)</code>, await completion with Node’s stream utilities:</p>\n<pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword module\">import</span> <span class=\"token imports\"><span class=\"token punctuation\">{</span> finished <span class=\"token punctuation\">}</span></span> <span class=\"token keyword module\">from</span> <span class=\"token string\">'stream/promises'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> writer <span class=\"token operator\">=</span> serializer<span class=\"token punctuation\">.</span><span class=\"token keyword module\">import</span><span class=\"token punctuation\">(</span>quadStream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// returns a Node stream</span>\n<span class=\"token keyword control-flow\">await</span> <span class=\"token function\">finished</span><span class=\"token punctuation\">(</span>writer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// resolves on 'finish' or rejects on error</span>\n</code></pre>\n</li>\n<li>\n<p>For stream pipelines, use <code>pipeline</code>:</p>\n<pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword module\">import</span> <span class=\"token imports\"><span class=\"token punctuation\">{</span> pipeline <span class=\"token punctuation\">}</span></span> <span class=\"token keyword module\">from</span> <span class=\"token string\">'stream/promises'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword control-flow\">await</span> <span class=\"token function\">pipeline</span><span class=\"token punctuation\">(</span>sourceStream<span class=\"token punctuation\">,</span> transformA<span class=\"token punctuation\">,</span> transformB<span class=\"token punctuation\">,</span> destStream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n</li>\n<li>\n<p>Comunica result streams (bindings/quad streams) also support async iteration:</p>\n<pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> data <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword control-flow\">await</span> engine<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">query</span><span class=\"token punctuation\">(</span><span class=\"token string\">'CONSTRUCT {...}'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> sources <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword control-flow\">for</span> <span class=\"token keyword control-flow\">await</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> quad <span class=\"token keyword\">of</span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* ... */</span> <span class=\"token punctuation\">}</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>Collecting small results only:</p>\n<pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword module\">import</span> <span class=\"token imports\">arrayifyStream</span> <span class=\"token keyword module\">from</span> <span class=\"token string\">'arrayify-stream'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> quads <span class=\"token operator\">=</span> <span class=\"token keyword control-flow\">await</span> <span class=\"token function\">arrayifyStream</span><span class=\"token punctuation\">(</span>quadStream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// OK for small datasets</span>\n</code></pre>\n<p>Avoid this for large data.</p>\n</li>\n<li>\n<p>Writing to stores:</p>\n<pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// RDF/JS store that exposes import()</span>\n<span class=\"token keyword\">const</span> importing <span class=\"token operator\">=</span> store<span class=\"token punctuation\">.</span><span class=\"token keyword module\">import</span><span class=\"token punctuation\">(</span>quadStream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword control-flow\">await</span> <span class=\"token function\">finished</span><span class=\"token punctuation\">(</span>importing<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n</li>\n</ul>\n<p>Rule of thumb to include:\nUse <code>await</code> for Promises and stream completion. Use <code>for await...of</code> to consume streaming RDF. Avoid <code>await</code> inside <code>'data'</code> listeners and avoid buffering everything unless you explicitly need it.</p>\n<h3 id=\"error-handling-and-logging-system-patterns\">Error Handling and Logging System Patterns<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#error-handling-and-logging-system-patterns\"></a></h3>\n<p>see <a href=\"/sflo/notes/ewpjwhqsry5j49gdfj9xd0b\">Logging and Error Handling</a></p>\n<hr>\n<strong>Backlinks</strong>\n<ul>\n<li><a href=\"/sflo/notes/xqjr13fyons9goxv8rjrskj\">Todo</a></li>\n<li><a href=\"/sflo/notes/g97elh6q5bszy2c74gsmuqk\">2025 11 03 Optimizing for Agents</a></li>\n</ul>","noteIndex":{"id":"voy7zrf0f6bs86m02uadhaf","title":"Semantic Flow Documentation","desc":"","updated":1756155165637,"created":1755709990079,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"documentation","selfContained":false,"name":"sflo"},"contentHash":"05284b47f8aa47c962f0ff2a3c3ac13a","links":[{"type":"wiki","from":{"fname":"root","id":"voy7zrf0f6bs86m02uadhaf","vaultName":"sflo"},"value":"now","position":{"start":{"line":4,"column":1,"offset":107},"end":{"line":4,"column":8,"offset":114},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"now"}},{"type":"wiki","from":{"fname":"root","id":"voy7zrf0f6bs86m02uadhaf","vaultName":"sflo"},"value":"todo","position":{"start":{"line":4,"column":11,"offset":117},"end":{"line":4,"column":19,"offset":125},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"todo"}},{"type":"wiki","from":{"fname":"root","id":"voy7zrf0f6bs86m02uadhaf","vaultName":"sflo"},"value":"principle","position":{"start":{"line":4,"column":22,"offset":128},"end":{"line":4,"column":35,"offset":141},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"principle"}},{"type":"wiki","from":{"fname":"root","id":"voy7zrf0f6bs86m02uadhaf","vaultName":"sflo"},"value":"dev.contributor.djradon.dev-log","position":{"start":{"line":4,"column":38,"offset":144},"end":{"line":4,"column":73,"offset":179},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"dev.contributor.djradon.dev-log"}},{"type":"wiki","from":{"fname":"root","id":"voy7zrf0f6bs86m02uadhaf","vaultName":"sflo"},"value":"concept.mesh-repo","position":{"start":{"line":10,"column":1,"offset":498},"end":{"line":10,"column":22,"offset":519},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"concept.mesh-repo"}},{"type":"wiki","from":{"fname":"root","id":"voy7zrf0f6bs86m02uadhaf","vaultName":"sflo"},"value":"concept.mesh","position":{"start":{"line":10,"column":40,"offset":537},"end":{"line":10,"column":56,"offset":553},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"concept.mesh"}},{"type":"wiki","from":{"fname":"root","id":"voy7zrf0f6bs86m02uadhaf","vaultName":"sflo"},"value":"concept.semantic-flow-site","position":{"start":{"line":10,"column":105,"offset":602},"end":{"line":10,"column":135,"offset":632},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"concept.semantic-flow-site"}},{"type":"wiki","from":{"fname":"root","id":"voy7zrf0f6bs86m02uadhaf","vaultName":"sflo"},"value":"feature","position":{"start":{"line":23,"column":7,"offset":1046},"end":{"line":23,"column":18,"offset":1057},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"feature"}}],"anchors":{"what-is-semantic-flow":{"type":"header","text":"What Is Semantic Flow?","value":"what-is-semantic-flow","line":12,"column":0,"depth":2},"benefits":{"type":"header","text":"Benefits","value":"benefits","line":18,"column":0,"depth":2},"features":{"type":"header","text":"Features","value":"features","line":25,"column":0,"depth":2}},"children":["p0vd6xnshcxw14ztkglxyxn","qa6hqxy4tknnmutvq13onaq","facets","faq000","ggle3sz2jv3vf53t9qplrzo","mesh-file","mesh-folder","guides","mesh-resource","yxn5rsqsv2gq4s6wbnxsjsj","l9g8eki3dtir51o4jagac5a","28q7fh05bs691llgv7htxnw","products","tkw34hrqxficesa0y2r62s0","xqjr13fyons9goxv8rjrskj","use-cases","8lbblgh43pkx93frnrb48qq","5w9g6pav1kogbqzp8618jxv","dypxioqhqlvodpkdk1ce0kx"],"parent":null,"data":{},"body":"\n**Dereferenceable, versioned semantic meshes** will be the foundation for a new era of knowledge graphs.\n\n[[now]] | [[todo]] | [[principle]] | [[dev.contributor.djradon.dev-log]]\n\n## What Is Semantic Flow?\n\n**Semantic Flow** is a framework for managing and publishing resource identifiers, knowledge graphs and other semantic data by leveraging GitHub, Gitlab, and other free static hosting services. It enables a **dereferenceable Semantic Web** where every HTTP IRI returns meaningful content.\n\n[[concept.mesh-repo]] provide storage, [[concept.mesh]] provide resource management and publishing, and [[concept.semantic-flow-site]] support data discovery and explainability.\n\n## Benefits\n\n- own your own self-describing data and data schemas\n- complete version history when you want it\n- reliable persistence\n- truly FAIR (Findable, Accessible, Interoperable, and Reusable)\n\n## Features\n\n- seamlessly integrate other data sources anywhere in your mesh\n- generate and customize mini-sites or single-page applications for nodes in your mesh\n- see [[feature]] for a list of planned features\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true,"enableSelfContainedVaults":true},"commands":{"lookup":{"note":{"selectionMode":"none","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"selection","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"documentation","selfContained":false,"name":"sflo"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"task","dateFormat":"y.MM.dd","addBehavior":"asOwnDomain","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"taskCompleteStatus":["done","x"],"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link"},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":true,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"enableFullHierarchyNoteTitle":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Semantic Flow Docs","description":"A dendron-based wiki for sflo"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"search","siteUrl":"https://semantic-flow.github.io/sflo","assetsPrefix":"/sflo","siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true}